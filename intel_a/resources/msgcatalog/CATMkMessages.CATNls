mkmkMPInit = "Unable to initialize multiprocessing mode.";
mkTraceManager.Parse.NoXmlKeysFile = "file named [/P1] not found in mkmk installation path.";
mkTraceManager.Parse.BadXmlKeysFileFormat = "file named [/P1] is incomplete: key [/P2] or [/P3] not found or empty.";
mkTraceManager.Parse.BadTagType = "parsing file named [/P1]: tag [/P2] has a bad type [/P3], value must be (/P4).";
mkTraceManager.Parse.DuplicatedTag = "parsing file named [/P1]: definition of tag [/P2] duplicated.";
mkTraceManager.Parse.BadTagFormat = "parsing file named [/P1]: definition of tag [/P2] is incomplete: key [/P3] or [/P4] not found or empty.";
mkTraceManager.Parse.NoTagFound = "parsing file named [/P1]: definition of message [/P2] reference a non-existing tag [/P3].";
mkTraceManager.Parse.BadTagMode = "parsing file named [/P1]: definition of message [/P2] reference a bad tag mode [/P3], value must be (/P4).";
mkTraceManager.Parse.BadMsgFormat = "parsing file named [/P1]: definition of message [/P2] is incomplete: key [/P3] or [/P4] not found or empty or has a bad size.";
mkTraceManager.Parse.DuplicatedMsg = "parsing file named [/P1]: definition of message [/P2] duplicated.";
mkTraceManager.Parse.BadTagMapping = "parsing file named [/P1]: definition of message [/P2] reference a bad tag mapping [/P3], value must be (/P4).";
mkTraceManager.NoMsgKey = "message key [/P1] not found in file named [/P2].";

errLic1 = "License settings not found or invalid: use the CATVBTLicenser tool to configure your RADE licenses or point the RADECATSettingPath variable to your RADE settings directory.";
errLic2 = "RequestLicensesFromSettings: error: at least one required license could not be got.";
errLic3 = "RequestLicensesFromSettings: error: the requested licenses do not authorize the given product, /P1.";
errLicDS = "RequestLicensesFromSettings: error: InternalDS license found, not authorized for this product.";

CAAV5Error = "# CAAV5-ERROR: /P1";
CAAV5Warning = "# CAAV5-WARNING: /P1";

CAAV5errCorrupted = "reference file [/P1] is corrupted (or empty).";
CAAV5errLicence = "unauthorized API for CAA V5: /P1";
CAAV5wngDeprecated = "deprecated API for CAA V5: /P1";

errStepDef = "invalid step definition, [/P1] is ignored !";
errStepOrder = "step /P1 may not be executed before step /P2";
errBldAct = "step /P1, unable to build actions, is ignored !";
errImpl = "no implementation provided for instance named: /P1";
errPPlvl = "/P1: line /P2, '#ifdef' clause encountered without valid set of definitions (perhaps a missing CATIAV5Level.h).";
errPPse = "/P1: line /P2, syntax error.";
errPPsns = "/P1: line /P2, syntax not supported.";
errPPmiss = "/P1: line /P2, /P3 statement missing.";
errPPblnk = "/P1: line /P2, blank required after /P3 statement.";
errPPincrecursive = "/P1: Error: recursive include nesting /P2.";
errPPincnotfound = "/P1: Error: Could not open include file /P2.";
errNoMacLvl = "unable to initialize macro level with file named [/P1] (perhaps a missing CATIAV5Level.h).";


errBONotASource = "file named [/P1] is ignored since it cannot be used as a [/P2].";
errBOSrcHasNoDerived = "/P1: the list of derived objects cannot be empty for this source.";

systError = "# syst-ERROR: [/P1]: /P2";
mkmkError = "# mkmk-ERROR: /P1";
mkmkErrorExtended = "# mkmk-ERROR: /P1";
mkmkWarning = "# mkmk-WARNING: /P1";
mkmkWarningExtended = "# mkmk-WARNING: /P1";

mkmkErrorWithId = "# mkmk-ERROR: (/P1): /P2";
mkmkErrorExtendedWithId = "# mkmk-ERROR: (/P1): /P2";
mkmkWarningWithId = "# mkmk-WARNING: (/P1): /P2";
mkmkWarningExtendedWithId = "# mkmk-WARNING: (/P1): /P2";

mkmkMessage = "#        /P1";
mkmkInfo = "# mkmk-INFO: /P1";
makeBegin = "# make: /P6 /P4";
makeEnd = "";
makeError = "# make-ERROR: /P5";
makeWarning = "# make-WARNING: /P5";
stepStart = "\n## start step: /P1   at /P2";
stepEnd = "## end   step: /P1   at /P2";
cleanup = "# cleanup: /P1 into /P2";
mkmkFatal = "# mkmk-FATAL: /P1";
atpError = "# atp-ERROR: /P4";
atpWarning = "# atp-WARNING: /P4";
atpInfo = "# atp-INFO: /P1";

errSrcNotFound = "/P1 was not found";
errGetWSEFailed = "Cannot retreive data for workspace element named [/P1].";

file.readErr = "/P1: An error occurred while reading file.";
file.writeErr = "/P1: An error occurred while writing file.";

filebuf.systError = "/P1: /P2";
filebuf.badCRC = "/P1: corrupted file, CRC error.";
filebuf.badVersion = "/P1: corrupted file, Version error.";
filebuf.badSize = "/P1: corrupted file, Size error.";
filebuf.badCryptVersion = "/P1: Unable to read file, unknown crypt level.";
filebuf.BadVersionID = "/P1: Unable to read file, identification version [/P2] does not match expected one [/P3].";

mkAnInvMod_r    = "/P1: Module [/P2] in /P3 is ignored since it is an invalid module.";
mkABuildNoMod_r = "/P1: Module [/P2] in /P3 is ignored since it is not built.";
errBadTxtVersionExt = "/P1: bad extension for TXTVERSION [/P2]; must be [/P3].";

BadJPONameStartNumber = "/P1: Invalid JPO file name [/P2] because it starts by a number.";
BadJPONameBadChar = "/P1: Invalid JPO file name [/P2] because it contains this character: '/P3'.";

mkdataErrorOccured = "Error(s) occurred during data update.";

mkmkFatal.Internal = "Fatal internal error: /P1 in /P2.";
mkmkFatal.InternalLine = "Fatal internal error: /P1 at line /P2 in /P3.";
mkmkFatal.Abort = "Fatal error: abort with exit code /P1.";
mkmkFatal.Interrupt = "interrupt.";
mkmkFatal.Allocate = "Fatal internal error: Unable to allocate buffer (type=/P1, size=/P2).";

mkDG.BadGraphRead = "/P1: READING: inconsistent dependencies graph detected.";
mkDG.BadGraphWrite = "/P1: WRITING: inconsistent dependencies graph detected.";
mkDG.BadGraphRemoved="/P1: inconsistent dependencies graph has been removed.";
mkDG.BadGraphVer="/P1: graph version /P2 not supported, may be a wrong tools level.";
mkDG.BadGraphMagic= "/P1: bad magic [/P2], not a valid graph.";
mkDG.BadGraphTooSmall= "/P1: the size of the buffer (/P2) is too small to contain a valid graph.";
mkDG.BadGraphSize="/P1: graph size read from the graph (/P2) does not match the file size (/P3).";
mkDG.BadGraphNbElem="/P1: the number of records to write (/P2) is greater than the number of records of the graph (/P3).";
mkDG.BadGraphRecord="/P1: Inconsistent records detected in a dependencies graph.";

mkDG.BadRecordInconsistent="Inconsistent record for element [/P1,UID=/P2].";
mkDG.BadRecordVer="Record version /P1 not supported, may be a wrong tools level.";
mkDG.BadRecTooSmall= "The size of the buffer (/P1) is too small to contain a valid graph record.";
mkDG.BadRecSize="Record size read from the graph (/P1) does not match the expected size (/P2).";
mkDG.BadRecBufSize= "The size of the buffer (/P1) is too small to contain the size of the record (/P2).";
mkDG.BadRecNoDGMElement= "Unable to read or write a graph record with no associated mkDGMElement or mkBOIntf.";
mkDG.BadRecLinkNotExist= "Inconsistent record links table detected, [UID=/P1] does not exist.";
mkDG.BadRecLinkWithNonExisting= "Unable to link graph element [/P1,UID=/P2] with non-existing elements.";

mkDG.BadDepDOisUSED = "Inconsistent dependencies detected, DERIVED object [/P1] cannot be a USED.";
mkDG.BadDepUseaDO = "Inconsistent dependencies detected, [/P1] cannot USE the DERIVED object named [/P2].";

mkDG.IncompleteGraph = "/P1: Cannot write an incomplete dependencies graph.";
mkDG.InvalidObject = "/P1: inconsistent dependencies detected, object named [/P2] is not valid.";
mkDG.RecUnexpected="Unexpected error reached.";

mkDG.KeepStatus       = "/P1: (/P2) status remains '/P3'.";
mkDG.SetStatusTo      = "/P1: (/P2) status has been set to '/P3'.";
mkDG.SetStatusToDueTo = "/P1: (/P2) status has been changed to '/P3' due to /P4.";
mkDG.SetSrcNotUpToDate= "/P1: (/P2) status has been set to '/P3' due to current status '/P4'.";
mkDG.SetModified      = "/P1: (/P2) status has been set to '/P3' due to object modifications.";
mkDG.SetModified.DerivedList = "/P1: (/P2) status has been set to '/P3' due to a new list of derived objects.";
mkDG.SetModified.UsedList = "/P1: (/P2) status has been set to '/P3' due to a new list of used objects.";
mkDG.SetGlobalFailed  = "/P1: (/P2) status has been set to '/P3' due to global make return code.";

ppv4.NoMacroLEVEL="PreproV4: Unable to pre-process files without a valid set of defines, check macro LEVEL.";
V4.MDF.DuplicateSection = "Error while reading MDF named [/P1]: redefinition for keyword [/P2] is not allowed.";

mkbs.xrefdouble = "/P1: [/P2] was doubly DERIVED";
mkbs.obsoletesrcused="/P1: internal error, this object is a USED OBSOLETE SOURCE";
mkbs.errNoWSEImpl= "/P1: internal error, this class is not a valid mkWSEIntf implementation, mkWSEFactory failed.";
mkbs.errNoBOImpl= "/P1: internal error, this class is not a valid mkBOIntf implementation for object [/P2], mkBOFactory failed.";
mkbs.errNoActImpl= "/P1: internal error, this class is not a valid mkActionIntf implementation, mkActionFactory failed.";
mkbs.errNoMethode= "/P1: internal error, objects with type [/P2] do not implement method for [/P3].";
mkbs.errNoRemove = "/P1: internal error, cannot remove objects with type [/P2] and class [/P3].";
mkbs.errCannotExec = "/P1: internal error, cannot execute build step [/P2].";
mkbs.NoScramblerInstance = "Unable to get a valid Scrambler instance";
mkbs.badVarValue = "/P1: internal error, check value of /P2.";

errCATComponentCOMPIL_r = "Identity card: error while compiling /P1 from /P2";
errCopyrightROOTPATH_r  = "Identity card: error: Environment variable CopyrightROOT_PATH is not set correctly";
errCopyrightMacro_r = "Identity card: error: macro [/P1] not found in /P2.";
packageWarn_r = "/P1: Invalid package name, ignored.";
imbalance_r = "error while parsing file [/P1]: [/P2] missing character '/P3'.";
nomacro_r			= "/P1: Macro named [/P2] (/P3) is not defined.";
nomacro_ext			= "/P1: List of last loaded file names:";
nomacro_lastloaded	= "/P1:  - [/P2]";
UnexpectedMainCommand = "Unexpected command type in mkmkMain starter, mkmk internal error.";
filenotfoundinmkmk = "file named [/P1] not found in mkmk installation path.";
optnojavawng = "Option -nojava : causes unpredictable results. Java has to be build on all platform because of the generation of the Java Native Interfaces \n";
nodeclfile_r = "/P1: File named [/P2] not found in mkmk installation path.";
BSNotForMe_r = "/P1: /P2: This step is not valid for this module.";
BSNotForMeFw_r = "/P1: /P2: This step is not valid for this framework.";
BSHasNoSrc_r = "/P1: /P2: The list of sources cannot be empty for this step.";
RTVduplicate_r = "Duplicated file /P1 from /P2 and /P3";
BadMacroValue = "Macro named [/P1] in Imakefile.mk has a bad value [/P2]: Local, Private, Protected or Public is requested.";
MoveFileErr = "Failed to move file /P1";
RemoveFileErr = "Failed to remove file /P1"; 
CreateFileErr = "Failed to create file /P1";     
RTVRecTooLong = "Internal error, size of record (/P2) [/P1] exceed allowed mkRTViewElement size (/P3).";
mkAPI.GenericMessage_r  = "/P1: /P2";

customCommand.CommandNotImplemented = "Configuration File [/P1]: The Custom Command [/P2] is not well implemented (no .COMMAND). The Custom Command is ignored.";
customCommand.FilesNotImplemented = "Configuration File [/P1]: The Custom Command [/P2] is not well implemented (no .FILES). The Custom Command is useless.";
customCommand.DuplicatedFileName = "Configuration File [/P1]: The source file [/P2] is in more than one Custom Command.";
customCommand.LoadCustomFile = "Unable to load the Configuration File [/P1]"; 
customCommand.InsertFileNameAndMacro = "Configuration File [/P1]: Failed to insert [/P2,/P3] in dictionnary.";

mkAPI.mkWSEMngrFailedMacro_r  = "/P1: While reading '/P2': /P3";
mkAPI.mkWSENotaFW = "/P1: Is not a Framework";

mkAPI.mkBadFWNameCase_r  = "Bad case for framework name [/P1], it has previously been used as [/P2]";
mkAPI.mkBadModNameCase_r = "Bad case for module name [/P1], it has previously been used as [/P2]";
mkAPI.mkBadFWNameCase2_r  = "/P1: /P2";

mkAPI.mkNoDeclModType_r = "/P1: This BUILT_OBJECT_TYPE cannot be correctly implemented.";
mkAPI.ReadMakefileErr_r = "/P1/P2: An error occurred while reading file /P3: /P4";
mkAPI.PPMakefileErr_r = "Errors occured during preprocessing phase.";

mkAPI.mkMODNotFound_r = "/P1: Directory [/P1.m*] was not found in specified workspace(s), then module [/P1] does not exist.";
mkAPI.mkFWNotFound_r = "/P1: Framework /P1 was not found in specified workspace(s).";

mkAPI.mkLoadCIFailed_r= "/P1: The script of the identity card cannot be load.";
mkAPI.mkLoadCIXMLFailed_r= "/P1: /P2 cannot be load.";

mkAPI.FWPreqAddIndirect = "/P1: A new prerequisite [/P2] has been added due to [/P3]";
mkAPI.FWPreqUpdAccess = "/P1: The access mode to prerequisite [/P2] has been updated from /P3 to /P4";
mkAPI.FWPreqUpdExport = "/P1: The exported mode of prerequisite [/P2] has been updated from /P3 to /P4 due to [/P5]";
mkAPI.FwPrereqLevelNotGranted = "/P1: The requested access /P3 is not granted by framework [/P2], the access mode to [/P2] has been updated from /P3 to /P4.";
mkAPI.FwPrereqNotGranted = "/P1: Requested an access /P3 on [/P2] but is not authorized to have any prerequisite. The prerequisite [/P2] has been removed.";
mkAPI.fwPrereqPrivateWhenNoAuth = "/P1: granted Private access on framework [/P2] which has no authorization. In future version, the access will be downgraded to Protected";
mkAPI.fwBrandlessPrereqFwWithBrand = "/P1: Found a prereq on [/P2] but their brands are uncompatible because [/P1] is brandless but not [/P2]. Prereq will be removed."; 
mkAPI.fwUncompatibleBrand = "/P1: Found a prereq on [/P2] but their brands are uncompatible because [/P1] is branded '/P3' but not [/P2]. Prereq will be removed."; 
mkAPI.FWPreqOnWrongType= "/P1: cannot prereq [/P2], their types are not compatible. The prerequisite on [/P2] has been removed"; 
mkAPI.FWRTPreqOnWrongType = "/P1: cannot prereq runtime [/P2], their types are not compatible. The runtime prerequisite on [/P2] has been removed"; 
mkAPI.FWRTPreqCycle = "/P1: runtime prerequisite cyclicity involving /P1 and /P2"; 
mkAPI.FWRTPreqNotUnique = "/P1: duplicate runtimeOnlyPrerequisite on /P2"; 
mkAPI.FWToolPrereqOnNonToolFw = "/P1: cannot have a tool dependency on a non tool framework [/P2]";
mkAPI.FWToolPrereqFromToolFw = "/P1: cannot have a tool dependency on [/P2] because /P1 is a tool framework";
mkAPI.FWPrereqOnNotPacked = "/P1: cannot have a dependency on [/P2] because /P2 is a not packaged. /P1 is set to INVALID and will not be builded";

mkAPI.FWDirPreqDuplicated = "/P1: Duplicated direct prerequisite to framework [/P2] as (/P3) is ignored since it already exists as (/P4).";
mkAPI.FWDirPreqAnInvFW = "/P1: Direct required framework [/P2] is ignored since it is an invalid framework.";
mkAPI.FWDirPreqABuildNoFW = "/P1: Direct required framework [/P2] is ignored since it is not built.";
mkAPI.FWIndirPreqAnInvFW = "/P1: Indirect required framework [/P2] is ignored since it is an invalid framework.";
mkAPI.FWIndirPreqABuildNoFW = "/P1: Indirect required framework [/P2] is ignored since it is not built.";

mkAPI.mkCLRNotSupported_r   = "/P1/P2: The keyword ['/P3'] in Imakefile.mk is ignored since it is not supported for modules with BUILT_OBJECT_TYPE [/P4].";
mkAPI.mkLWNoClientServer_r  = "/P1/P2: Module /P3 [/P4] in LINK_WITH is ignored since neither CLIENT nor SERVER has been specified.";
mkAPI.mkDupModPath_r        = "/P1: This module was previously found in [/P2]. Module [/P3] in [/P4] is ignored.";
mkAPI.mkComdynIsABAD_r      = "/P1/P2: Module [/P3] in COMDYN_MODULE is ignored since its type '/P4' is not compatible.";
mkAPI.mkEncoded_r           = "/P1/P2: Decoding authorization failed, set to read-only.";
mkAPI.mkBldDlkAWOPKToken_r  = "/P1/P2: [/P3=/P4] in Imakefile.mk and no valid [/P5] found, set to read-only.";
mkAPI.mkCycleDetected_r     = "/P1: /P2";
mkAPI.mkCycleNotBuilt_r     = "/P1/P2: This module is not built due to nested LINK_WITH detection: /P3.";
mkAPI.mkBadModExt_r         = "/P1/P2: The module extension is not valid.";
mkAPI.mkBadModType_r        = "/P1/P2: This module has an invalid BUILT_OBJECT_TYPE [/P3].";
mkAPI.mkDataMiss_r          = "DATA [/P1] is not valued, configuration files are missing or incomplete (check .../tools/config/*.mk files).";
mkAPI.mkMacDefLoop_r        = "Recursive Macro definitions are not allowed. Macro [/P1 = /P2] will not be correctly expanded.";
mkAPI.mkMacDefMiss_r        = "MACRO definition [/P1 = /P2] is in error. Character [/P3] imbalance.";
mkAPI.mkBadImplement_r      = "/P1: This /P2 cannot be correctly implemented.";
mkAPI.mkBadOpt_r            = "/P1: Option [/P2] is not authorized for this command.";
mkAPI.mkBadOptMisVal_r      = "/P1: Option [/P2] requires an argument.";
mkAPI.mkFailedToInitEnv_r   = "Command Environment: Variable [/P1] is not set.";
mkAPI.mkCantChgDir_r        = "/P1: Failed to change to directory.";
mkAPI.mkDupEnv_r            = "Command Environment: An attempt was made to set the environment while an other exists. Don't use SetEnvironment more than one time.";
mkAPI.mkBadConcat_r         = "Concatenation: A pathname specified in the concatenation list cannot be access.";
mkAPI.mkFileNotFound_r      = "/P1: This file does not exist.";
mkAPI.mkWSNotInConcat_r     = "/P1: This workspace is not in the concatenation list.";
mkAPI.mkLinkWithNotDirectNONE_r = "/P1/P2: Module [/P3] in LINK_WITH was added due to [/P4].";
mkAPI.mkNotIncluded_r       = "/P1/P2: Is a `NONE' module which never appears as INCLUDED_MODULES. [/P2] automatically changed to 'BUILD=NO'.";
mkAPI.mkIncludedOutOfFW_r   = "/P1/P2: This module cannot INCLUDE module [/P3/P4] outside its framework. Include of [/P4] is ignored.";
mkAPI.mkIncludedTwice_r     = "/P1/P2: This module cannot INCLUDE module [/P3/P4] since it is already included in [/P5]. Include of [/P4] is ignored.";
mkAPI.mkIncludedByAnOther_r = "/P1/P2: This module cannot INCLUDE module [/P3/P4] since it is already INCLUDED_BY [/P5]. Include of [/P4] is ignored.";
mkAPI.mkIncludedByAnInvMod_r= "/P1/P2: This module cannot be INCLUDED_BY module [/P3/P4] since it is not valid.";
mkAPI.mkIncludeABAD_r       = "/P1/P2: Module [/P3] in INCLUDED_MODULES is ignored since it is an invalid module.";
mkAPI.mkIncludeABuildNo_r  = "/P1/P2: Module [/P3] in INCLUDED_MODULES is ignored since it is not built.";
mkAPI.mkNotaNONE_r          = "/P1/P2: Included module [/P3] is ignored since [/P3] is of type [/P4] instead of [NONE].";
mkAPI.mkBigNotAdded_r       = "/P1/P2: Module [/P3/P4] cannot be automatically added because its framework [/P3] was not in the list of frameworks to build.";
mkAPI.mkLinkWithProgSubDir  = "/P1/P2: Module [/P3] in LINK_WITH is ignored since it uses Imakefile.mk keyword [PROGRAM_SUBDIR].";
mkAPI.mkLinkWithABAD_r      = "/P1/P2: Module [/P3] in LINK_WITH is ignored since its type '/P4' is incompatible with type '/P5'.";
mkAPI.mkSRVLinkWithAJPO_r   = "/P1/P2: Module [/P3] in LINK_WITH is ignored since its type '/P4' is incompatible with type '/P5' without JPO=YES.";
mkAPI.mkCLRLinkWithABAD_r   = "/P1/P2: Module [/P3] in CLR_LINK_WITH is ignored since either its type '/P4' is incompatible with type '/P5' or it is not a .NET library.";
mkAPI.mkFoundAnAlias_r  = "/P1/P2/P3: Definitions of aliases are prohibited and must be removed.";
mkAPI.mkLinkWithAnAlias_r  = "/P1/P2/P3: Module [/P4], which is defined as an alias, was automatically added in LINK_WITH.";
mkAPI.mkLinkWithAnAliasNotDirect_r  = "/P1/P2: Module [/P3], automatically added in LINK_WITH, is used although it is in framework [/P4] which is not a direct prerequisite.";
mkAPI.mkLinkWithAnInvMod_r  = "/P1/P2: Module [/P3] in LINK_WITH is ignored since it is an invalid module.";
mkAPI.mkLinkWithABuildNo_r  = "/P1/P2: Module [/P3] in LINK_WITH is ignored since it is not built.";
mkAPI.mkLinkWithAnInvFW_r   = "/P1/P2: Module [/P3] in LINK_WITH is ignored since it is in framework [/P4] which is invalid.";
mkAPI.mkLinkWithNotDirect_r = "/P1/P2: Module [/P3] in LINK_WITH is ignored since it is in framework [/P4] which is not a direct prerequisite.";
// mkAPI.mkLinkWithOnArchNotDirect_r = "/P1/P2: Archive [/P3] in LINK_WITH is ignored since it is in framework [/P4] which is not a direct prerequisite or buildtimeOnlyPrereq.";
mkAPI.mkLinkWithOnArchNotDirect_r = "/P1/P2: Archive [/P3] in LINK_WITH will be ignored in future version since it is in framework [/P4] which is not a direct prerequisite or buildtimeOnlyPrereq.";
mkAPI.mkSrcLinkWithABAD_r      = "/P1/P2: Module [/P3] in SRC_LINK_WITH is ignored since its type '/P4' is incompatible with type '/P5'.";
mkAPI.mkSrcLinkWithAnInvMod_r  = "/P1/P2: Module [/P3] in SRC_LINK_WITH is ignored since it is an invalid module.";
mkAPI.mkSrcLinkWithAnInvFW_r   = "/P1/P2: Module [/P3] in SRC_LINK_WITH is ignored since it is in framework [/P4] which is invalid.";
mkAPI.mkSrcLinkWithNotDirect_r = "/P1/P2: Module [/P3] in SRC_LINK_WITH is ignored since it is in framework [/P4] which is not a direct prerequisite.";
// mkAPI.mkSrcLinkWithUnauth_r  = "/P1/P2: Module [/P3] in SRC_LINK_WITH is ignored since /P3 does not authorize it using ALLOW_STATIC_LINK=YES.";
mkAPI.mkSrcLinkWithUnauth_r  = "/P1/P2: Module [/P3] in SRC_LINK_WITH will be ignored in future version since /P3 does not authorize it using ALLOW_STATIC_LINK=YES.";
mkAPI.mkLinkWithUnauth_r  = "/P1/P2: Module [/P3] in LINK_WITH is ignored since /P3 is an archive, the prerequisite is buildtime only and  /P3 does not authorize LINK_WITH using ALLOW_STATIC_LINK=YES.";
mkAPI.mkLinkWithBTOnly_r  = "/P1/P2: Module [/P3] in LINK_WITH is ignored since it is in framework [/P4] which is buildtime only prerequisite.";
mkAPI.mkOpenFailed_r        = "/P1: Failed to open: /P2";
mkAPI.mkCannotLoad_r        = "/P1: Failed to load file.";
mkAPI.mkCreateFailed_r      = "/P1: Failed to create.";

mkAPI.mkBSSMACodeGen_DispatchImplemNotAllowed_r = "/P1: cannot dispatch file to implementation directory, this is not allowed for interface code generator.";
mkAPI.mkBSSMACodeGen_unknownDestination_r = "/P1: illegal value for destination /P2.";

mkAPI.errNoAutomaticPreqFound = "Unable to find the framework [/P1]. This framework contains various build resources. Its absence can provoke build errors";

mkFRONT.mkNothingToDo_r     = "Command line: There is no /P1 to work on. Use one option in the following list: [-a] or [-lFW lst] or [-lMod lst].";
mkFRONT.mkNoFW_r            = "/P1: This command must be executed in a workspace containing, at least, one framework.";
mkFRONT.mkWSEIsInvalid_r    = "/P1: This /P2 is not a valid object due to previous error.";
mkFRONT.mkGiveConcat_r      = "Concatenation: The list of paths is [/P1].";
mkFRONT.mkPATH_r            = "DEBUG: The Path will be [/P1].";
mkFRONT.mkLIBPATH_r         = "DEBUG: The Library path will be [/P1].";
mkFRONT.mkLoadShell_r       = "/P1: It is impossible to load this trame model.";
mkFRONT.mkLoadShell_r2      = "/P1: trame not found in runtime view  checking in tools path.";
mkFRONT.mkBackDir_r         = "DEBUG: Change directory back to [/P1].";
mkFRONT.mkShellInfo_r       = "mkrunM: The shell used to start the command is: [/P1]";
mkFRONT.mkBadOptErr_r       = "Command line: Syntax error.";
mkFRONT.mkNotAWS_r          = "/P1: This workspace is not valid.";
mkFRONT.mkCorruptedFile_r   = "/P1: This concatenation file is corrupted. Use the mkGetPreqM command to create a new one.";
mkFRONT.mkNoDitaOpenToolkit_r = "DITA Open Toolkit environment has not been found.";

BAD.xxx.Unexpected = "/P1: Unexpected BAD error detected for this object, internal error.";
BAD.xxx.InvalidID = "/P1: Invalid BAD error identifier, internal error.";
BAD.SrcUseABAD = "/P1: needs an interface containing BAD error(s): /P2";
BAD.RemoveDo = "/P1: removing associated derived object: /P2";
BAD.001.IncNotDirect = "/P1: BAD001: cannot use /P3 since it belongs to a framework which is not a direct prerequisite.";
BAD.002.IncNotDirect = "/P1: BAD002: cannot use /P3 since it belongs to a framework which is not a direct prerequisite.";
BAD.003.IncBadArchi  = "/P1: BAD003: /P2 file cannot use /P3 since it is /P4.";
BAD.008.IncLowerLevel = "/P1: BAD008: cannot use /P3 since it is /P4 and the direct prerequisite to /P6 is /P7.";
BAD.004.IncNotExposePrereq = "/P1: BAD004: cannot use /P3 since it belongs to a framework which is not an exposed prerequisite.";
BAD.005.FromSource = "/P1: /P2";
BAD.005.NeedNotDirect = "BAD005: needs /P3 (from /P1) and it belongs to a framework which is not a direct prerequisite.";

BAD.006.FWPreqRecursive = "/P1: BAD006: cyclic prerequisites detected, [/P1] appears in its own indirect prerequisites list. Cyclicity started from framework [/P2]";
BAD.007.ModLWRecursive = "/P1: BAD007: cyclic LINK_WITH detected. Cyclicity started from module [/P2]";

mkdoc.LocalTarget_r         = "Check /P1 /P2: Unnecessary target attribute value [/P3] has been detected in [/P4] file on hyperlink [/P5]. The hyperlink is to a file that is already part of the [/P3] structure.";
mkdoc.NoTarget_r            = "Check /P1 /P2: Forbidden target (/P3) has been detected in Related-Links (/P4)";
mkdoc.PreqNotBuilt_r        = "Check /P1 content: Module /P2 in LINKWITH has not been built";
mkdoc.nodeclfile_r          = "Index /P1: file named [/P2] not found in mkmk installation path.";
mkdoc.UnableToCopy_r        = "Publish /P1: Unable to copy /P2 to /P3";
mkdoc.PbPublish_r           = "Publish /P1: /P2";
mkdoc.NoBrand_r             = "Check /P1 structure: SetBrand is no more used. Remove it from your IdentityCard.h file";
mkdoc.XrefInRc_r            = "Check /P1 /P2: Forbidden link (/P3) has been detected in a Reuse Component (/P4)";
mkdoc.SeveralFiles_r        = "Check /P1 structure: Several files have been found in current module.";
mkdoc.UnableMap_r           = "Check /P1 structure: Unable to identify rootmap in current module.";
mkdoc.InvalidLink_r         = "Check /P1 /P2: [/P3] link not valid in /P4";
mkdoc.NotInSLW_r            = "Check /P1 /P2: /P3 module is not defined in SRC_LINK_WITH (declared in /P4)";
mkdoc.NotInLW_r             = "Check /P1 /P2: /P3 module in 'target' is not defined in LINK_WITH (declared in /P4)";
mkdoc.ImageNotInLW_r        = "Check /P1 content: /P2 module is not defined in LINK_WITH (declared in /P3)";
mkdoc.FileDuplicate_r       = "Check /P1 structure: File duplicate in rootmap (/P2)";
mkdoc.HtmLink_r             = "Check /P1 /P2: [/P3] forbidden htm link detected in /P4";
mkdoc.XmlNotInStruct_r      = "Check /P1 structure: xml file not referenced in global structure (/P2)";
mkdoc.CannotOpen_r          = "Check /P1 /P2: Unable to open file [/P3] declared in /P4";
mkdoc.Forbidden_r           = "Check /P1 /P2: Forbidden file name [/P3] declared in /P4";
mkdoc.MapTarget_r           = "Check /P1 content: /P2 module in 'target' must be a DOC_MAP module (declared in /P3)";
mkdoc.NoLang_r              = "Check /P1 content: Unable to identify xml:lang attribute in topic /P2";
mkdoc.Id2url_r              = "Check /P1 content: Incorrect prefix name for /P2 longhelpid (declared in /P3)";

mkdoc.NotAbsolute_r         = "Base path /P1 is not absolute";
mkdoc.BadOption_r           = "An option is missing";
mkdoc.Delete_r              = "File corresponding to /P1 has been deleted in current module";
mkdoc.NotISO_r              = "Error on file /P1 : Incorrect file name format";
mkdoc.NoExtension_r         = "Extension for file /P1 not implemented";
mkdoc.Blank_r               = "Error on file /P1 : Blank character not authorized";
mkdoc.Special_r             = "Error on file /P1 : Special character not authorized";
mkdoc.InvalidSubst_r        = "Invalid format for substitution file /P1";
mkdoc.TagNotClosed_r        = "Error in /P1: Tag not closed ( /P2 )";
mkdoc.EmptyLink_r           = "Error in /P1: Empty link ( /P2 )";
mkdoc.TagNotFound_r         = "Error in /P2: Tag /P1 has not been found";
mkdoc.AnchorNotResolved_r   = "'/P1' Anchor not resolved in source file /P2";
mkdoc.ExtAnchorNotResolved_r = "'/P1' External anchor not resolved in source file /P2";
mkdoc.Protocol_r            = "Protocol /P1 is used in source file /P2";
mkdoc.ForbidLink_r          = "Error in /P1 : A link with an element outside the workspace is not allowed: /P2";
mkdoc.NotInConfig_r         = "Error in /P1: File [/P2] is not in the same configuration";
mkdoc.NoFile_r              = "Error in /P1: No file at reference [/P2]";
mkdoc.NoFileSmall_r         = "Error in /P1: ( _small ) No file at reference [/P2]";
mkdoc.DocBaseRTV_r          = "Error in /P1: DOC_BASE cannot have several RTV as prerequisites (/P2)";
mkdoc.CommonRTV_r           = "Error in /P1: COMMON must only have COMMON RTV as prerequisites (/P2)";
mkdoc.NotInPrereq_r         = "Error in /P1: File [/P2] is not in a direct prerequisite framework or the module is not attached";
mkdoc.NotValidLink_r        = "This link is not valid: /P1";
mkdoc.InvalidTable_r        = "Invalid width definition of tag table in file /P1";
mkdoc.TwoNbsp_r             = "Two consecutive nbsp; definition in file /P1";
mkdoc.TwoBr_r               = "Two consecutive BR tag definition in file /P1";
mkdoc.Imbalance_r           = "Error in /P1: /P2 imbalance in TAG [/P3]";
mkdoc.NoDocref_r            = "Docref file not defined for /P1 file";
mkdoc.DuplFile_r            = "All tocs must be either manual (toc.htm) or automatic (toc.auto.htm)";
mkdoc.DuplFileAuto_r        = "Duplicated files detected ( /P1 and /P2 )";
mkdoc.NotBuilt_r            = "Module /P1 in LINKWITH has not been built";
mkdoc.NoProduct_r           = "PRODUCT_FOR_INDEX has not been defined in Imakefile.mk file";
mkdoc.BookmarkError_r       = "Error on file /P1 : Incorrect definition of bookmark : '/P2'";
mkdoc.CheckPII_r            = "CheckPII command has not be found";
mkdoc.Config_r              = "Config problem for file /P1 (LINKWITH, structure.cnf not found, not declared in structure ...)";
mkdoc.UnableToOpen_r        = "Unable to open file [/P1]";
mkdoc.FormatImage_r         = "Error in /P1 : /P2 format detected";

mkdocnew.Protocol_r         = "Absolute URL not allowed in documentation : /P1";
mkdocnew.AnchorNotResolved_r   = "/P1 Anchor not resolved";

mkidx.InvalidLocale_r       = "Error: The appropriate regional setting has not been set !";
mkidx.TitleError_r          = "title ended by [table] instead of [/h... in file /P1";
mkidx.DoesNotExist_r        = "File /P1 does not exist in the Documentation View.";
mkidx.Lang_r                = "The Language of input HTML documents is set to /P1";
mkidx.NotIndexed_r          = "File /P1 not indexed ( invalid format ).";

NoModuleData_r                    = "In framework /P1 module /P2 has no module.data associated.";
NoFrameworkData_r            = "Framework /P1 has no framework.data associated.";
TooManyFrameworkData_r            = "Framework /P1 has too many framework.data associated.";
NoImakefile_r                    = "/P1 has no Imakefile.mk associated.";
ExpandFailed                    = "/P1: Failed to expand [/P2].";

JavaAccessPrivate_r   = "Java file /P1 access a private class of /P2 : /P3.";
JavaAccessProtected_r  = "Java file /P1 access a protected class of /P2 : /P3.";
JavaNoneClassFile = "None of the expected \".class\" files to be archived exist, check the diagnostic of the compilation step.";
JavaDONotProduce_r = "Expected derived object named [/P1] does not exist, check your package name.";
JavaDuplicatedSource_r = "[/P1]: Duplicated source file [/P2] is ignored.";
JavaInvalidTYPE_r = "Invalid TYPE value [/P1] in Imakefile.mk, using CLIENT as default.";

JavaNotCompiledFiles = "/P1 is not compiled, because it is not in the right directory (this should be your src directory + /P2)";

DONotProduced_r  = "Expected derived object named [/P1] does not exist.";
SrcDoesNotProduceDO_r  = "/P1 does not produce /P2.";

Corba.PackageNoFound            = "Package directory [/P1] not found in source file [/P2]";
Corba.UnableToOpen            = "Unable to open file [/P1]";
Corba.UnableToCreate            = "Unable to create file [/P1]";
Corba.UnableToMap            = "Unable to map file [/P1] in memory";
Corba.UnableToFindString    = "Unable to find string [Interfaces] in [/P1]";
Corba.UnableCreateFileSize  = "Unable to create file [/P1] of size /P2 : /P3";
Corba.NotDerived            = "File named [/P1] seems to be a derived, but it says not, then it is ignored.";
Corba.MergeDuplicate            = "Merging duplicated files [/P1]";
Corba.IncludeNotFound            = "In source file [/P1]:(preprocessing): Cannot find include file [/P2]";

OCaml.notASource = "File named [/P1] was not found in sources dictionary";
OCaml.cyclicDependencies = "Cyclic dependencies graph detected: /P1";

CI.CopyrightNotFound = "Macro COPYRIGHT not found in /P1";
CI.internal = "Script Error >>> Internal error [/P1 \n/P2\n] <<<";
CI.filefailed = "Script Error >>> file: /P1 /P2 failed <<<";
CI.srcinvalid = "Script Error >>> file: /P1 invalid script file <<<";
CI.srcinvalidext = "Script Error >>> file: /P1 invalid script file extension <<<";
CI.outdir = "Script Warning >>> directory: /P1 default output directory <<<";
CI.syntaxerr = "Script Error >>> script syntax error, line: /P1 <<<";
CI.arginvalid = "Script Error >>> method: </P1>, argument: </P2> not valid <<<";
CI.nbarginvalid = "Script Error >>> method: </P1>, number of arguments: </P2> not valid <<<";
CI.cpllinefailed = "Script Error >>> file: /P1 line: /P2 compilation failed <<<";
CI.cplfailed = "Script Error >>> /P1 compilation failed <<<";

DynamicCreator.IgnoredName = "In '/P1' file, '/P2' element with 'Name' attribute '/P3' ignored: value is duplicated";
DynamicCreator.BadBoolValue = "In '/P1' file, 'Item' element with 'Name' attribute '/P2' has a bad 'Value' attribute '/P3': true or false is allowed";
DynamicCreator.NotFound = "File '/P1' is not found";
DynamicCreator.ScriptNotFound = "Unable to execute script file '/P1': no such file";
DynamicCreator.ProjectNotFound = "Unable to load project file '/P1': no such file";
DynamicCreator.NoFileElements = "For 'Item' element with 'Name' attribute '/P1' one or more 'File' elements with 'Name' attribute '/P2' are missing";
DynamicCreator.NoFileOrItemElements = "For 'Item' element with 'Name' attribute '/P1' one or more 'File' or 'Item' elements with 'Name' attribute '/P2' are missing";
DynamicCreator.NotAnInterface = "File '/P1' is not a Private, Protected or Public interface";
DynamicCreator.NotADerived = "File '/P1' seems to be a derived object, but it says not, then it is ignored";
DynamicCreator.NoObject = "Expected derived object does not exists";

VersionXML.ReservedName = "In '/P1' file, 'Item' element with 'Name' attribute '/P2' not authorized: value is reserved for internal use";
VersionXML.IgnoredName = "In '/P1' file, 'Item' element with 'Name' attribute '/P2' ignored: value is duplicated";
Version.UnableToMap            = "Unable to map version file [/P1] in memory";
Version.UnableToCreate            = "Unable to create version file [/P1]";
ProcessKilled                    = "Process killed due to end-of-timeout.";

logXMLParse.Date           ="/P2";

TAparser.ImbParenthese = "/P1: Missing end of '(' in CATLISTP() or CATLISTV() or SEQUENCE.";
TAparser.ImbBracket = "Problem : missing end of [ in delete[]";
TAparser.InvIdlArg = "Problem in arguments of idl method: /P1";
TAparser.InvCatIdlArg = "Problem in category of arguments idl method: /P1";

CIXML.xmlSourceNotFound = "- XML CI Compiler - Error source file not found : /P1 ";
CIXML.schemaNotFound = "- XML CI Compiler - Internal error schema not found : /P1 in /P2";
CIXML.internalError = "- XML CI Compiler - Internal error : /P1 ";
CIXML.error = "- XML CI Compiler - /P1 ";
CIXML.noTypeError = "- XML CI Compiler - No type defined in XML identity card , Type is mandatory ";

mkman.unknownversion="Error: Unable to retreive any version information from path [/P1], then internal version of tools will be used (/P2)";
mkman.badDirectory="Error: the target path /P1 is not a directory";
mkman.badFile="Error: cannot open in write mode file /P1";
mkman.badReadFile="Error: cannot open /P1 file in read mode";
mkman.noReadFile="Error: cannot read class file /P1";
mkman.badAllFiles="Error: not all /P1 file could be written";
mkman.noGetFileSize="Error: cannot get /P1 file size";
mkman.alreadyExists="Mkman error: /P1 already exists, aborted.";
mkman.150.101="Mismatch class : /P1 found in /P2 already defined in /P3 as /P4";
mkman.150.102="Mismatch struct decl: /P1 found in /P2 already defined in /P3 as /P4";
mkman.150.103="Mismatch define: /P1 found in /P2 already defined in /P3 as /P4";
mkman.150.104="Mismatch const declaration: /P1\nfound : /P2";
mkman.150.105="Mismatch typedef decl: /P1 found in /P2 already defined in /P3 as /P4";
mkman.150.106="Mismatch enum : /P1 found in /P2 already defined in /P3 as /P4";
mkman.150.107="/P1 found in /P2 already defined in /P3 as collection";

mkman.stripArg="+++ Stripped argument: /P1";
mkman.noWs="Error: no workspace. Set a workspace path in the CATDCRF_WS environment variable";
mkman.fatalError=" FATAL ERROR in mkmk environment ";
mkman.noAbsolutePath="Error: base path is not absolute";
mkman.noCopyPath="cannot copy /P1 path";

150.501="non documented /P1 /P2: /P3 in file /P4";
150.502="non documented deprecated /P1: /P2 in file /P3";
150.004="non L1 class reference: /P1 in file /P2";
150.005="missing file /P1.";
150.006="failed to open file list /P1.";
150.007="failed to open output file /P1.";
150.008="maximum path length reached on relative path /P1.";
150.009="illegal interface(s) path /P1.";
150.010="cannot create HTML output directory at path /P1.";
150.011="unresolved @see reference: /P1 in file /P2.";
150.012="unresolved @see reference: /P1.";
150.013="unresolved @href reference: /P1 in file /P2.";
150.014="unresolved @href reference: /P1.";
150.015="unresolved CAA Level tag : /P1 in file /P2.";
150.016="/P1 documentation exposure is invalid in file: /P2.";

mkcsc="# mkcsc-ERROR: /P1";
mkcsc.cannotLoadSettings="cannot load settings File : /P1";

//=====================================================================================
mkInstallConfig.file.read.corrupted = "/P1: This file does not contain a workspaces concatenation, it may be corrupted, empty or too large.";

