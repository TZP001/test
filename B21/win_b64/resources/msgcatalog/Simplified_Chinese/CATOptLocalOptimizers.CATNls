nbMaxEvalSmy = "结束运行状态";
nbMaxEvalMsg = " 梯度达到最大更新数\n若更新数目更大，则解法可能更佳。";
timeExceededMsg = " 梯度达到最大时间\n若更新数目更大，则解法可能更佳。";

timeExceededSmy = "结束运行状态";

consecutiveBadSmy = "结束运行状态";
consecutiveBadMsg = "梯度达到最大更新数，无法改进。";

NoFeasibleRegionFound = "此运算法则无法找到可行的起点。";

// SOC - 23/09/02
missingFreeParmMsg = "若要运行优化，请选择至少一个自由参数。\n";
missingFreeParmSmy = "缺少自由参数";
missingParamToOptimizeMsg = "此运算法则需要参数，从而进行优化操作。";
missingParamToOptimizeSmy = "缺少用于优化的参数";
algorithmCompatibilityMsg = "没有约束时无法使用此梯度算法。\n请创建至少一个约束，或在运算法则列表中选择“无约束梯度算法”";
algorithmCompatibilitySmy = "运算法则与定义的优化不兼容";
internalErrorSmy = "内部错误";


FirstUpdateError = "首次更新梯度时出错。局部搜索异常中止。";

GradientEvaluationError = " 计算向量梯度时出错。异常中止。";

EvaluationErrorAfterGradient = "向量梯度计算后无法恢复数值。局部搜索异常中止。";

EqualityConstraintsIgnored="所选运算法则不支持等式约束。已忽略所有等式约束。有关更多详细信息，请参见文档。";

OptimizerForDerivativesProviderName=" 导数提供程序的局部运算法则";
OptimizerCurrentEvaluation= " 计算";

ObjectiveNotDerProvider=" 目标不是导数提供程序。";
ConstraintsNoDer = "无法获得约束的导数";
ObjectiveNoDer = "无法获得目标的导数。";
ObjectiveUnableToGetOutputValues = "无法获得目标的输出值。";

AbsoluteBoundsReached = "至少已达到一个自由参数界限。";




