/**
 * © Dassault Systèmes 2008 – Do not reproduce, copy or use without a license from Dassault Systèmes
 * CGFX Shader for CATIA V5
 * Author: Jerome Derel
 * Date: 21.05.2008
 */


/******************************************************************/
/* DATA - STRUCTURES */
/******************************************************************/

struct LIGHT_INFOS
{
	float3 position;
	float3 direction;
	float4 ambient;
	float4 diffuse;
	float4 specular;
};

struct MATERIAL_INFOS
{
	float3 position;
	float3 normal;
	float3 tangent;
	float3 binormal;
};

struct CAMERA_INFOS
{
	float3 position;
	float3 direction;
};


struct LIGHT_RESULT
{
	float4 contribution;
};

struct ILLUMINATION_RESULT
{
	float4 ambient;
	float4 diffuse;
	float4 specular;
};


/******************************************************************/
/* LIGHT - PARAMETERS */
/******************************************************************/

#ifdef IN_FXCOMPOSER2
/* Simple lighting implementation in FXC2 */
float3 _LightPos : Position
<
	string Object = "PointLight0";
	string Space = "World";
	string UIName = "Light0 Light_position";
> = float3(0.0f,0.0f,0.0f);

float4 _LightAmbient
<
	string UIName = "Light0 Ambient Color";
	string UIWidget = "Color";
> = float4(0.2f,0.2f,0.2f,1.0f);

float4 _LightDiffuse
<
	string UIName = "Light0 Diffuse Color";
	string UIWidget = "Color";
> = float4(0.5f,0.5f,0.5f,1.0f);

float4 _LightSpecular
<
	string UIName = "Light0 Specular Color";
	string UIWidget = "Color";
> = float4(0.8f,0.8f,0.8f,1.0f);
#endif


/******************************************************************/
/* LIGHT - STRUCTURES */
/******************************************************************/

interface Light
{
	float3 getPosition(MATERIAL_INFOS material_infos);
	float3 getDirection(MATERIAL_INFOS material_infos);
	float4 getAmbient();
	float4 getDiffuse();
	float4 getSpecular();
	LIGHT_RESULT compute(MATERIAL_INFOS material_infos);
};

struct SLightDir : Light
{
	const float3 LightPos;
	const float3 LightDir;
	const float3 LightUp;
	const float3 LightRight;
	
	const float4 LightAmbient;
	const float4 LightDiffuse;
	const float4 LightSpecular;
	
	const float LightAxialFalloffStart;
	const float LightAxialFalloffEnd;
	const float LightAxialFalloffConstant;
	const float LightAxialFalloffLinear;
	const float LightAxialFalloffQuadratic;
	
	const float LightRadialInnerCone; /* cosf(InnerConeAngle * 3.14159f / 180.0f) */
	const float LightRadialOuterCone; /* cosf(OuterConeAngle * 3.14159f / 180.0f) */
	const float LightRadialFalloffExponent;
	
	const float LightAreaType;
	const float LightAreaStatus;
	const float2 LightAreaGeometry;
	
	
	float3 getPosition(MATERIAL_INFOS material_infos)
	{
		return LightPos;
	}
	
	float3 getDirection(MATERIAL_INFOS material_infos)
	{
		return LightDir;
	}
	
	float4 getAmbient()
	{
		return LightAmbient;
	}
	
	float4 getDiffuse()
	{
		return LightDiffuse;
	}
	
	float4 getSpecular()
	{
		return LightSpecular;
	}
	
	LIGHT_RESULT compute(MATERIAL_INFOS material_infos)
	{
		LIGHT_RESULT light_result = (LIGHT_RESULT)0;
		
		light_result.contribution = float4(1.0f,1.0f,1.0f,1.0f);
		
		
		return light_result;
	}
};

struct SLightPoint : Light
{
	const float3 LightPos;
	const float3 LightDir;
	const float3 LightUp;
	const float3 LightRight;
	
	const float4 LightAmbient;
	const float4 LightDiffuse;
	const float4 LightSpecular;
	
	const float LightAxialFalloffStart;
	const float LightAxialFalloffEnd;
	const float LightAxialFalloffConstant;
	const float LightAxialFalloffLinear;
	const float LightAxialFalloffQuadratic;
	
	const float LightRadialInnerCone; /* cosf(InnerConeAngle * 3.14159f / 180.0f) */
	const float LightRadialOuterCone; /* cosf(OuterConeAngle * 3.14159f / 180.0f) */
	const float LightRadialFalloffExponent;
	
	const float LightAreaType;
	const float LightAreaStatus;
	const float2 LightAreaGeometry;
	
	
	float3 getPosition(MATERIAL_INFOS material_infos)
	{
		#ifdef IN_FXCOMPOSER2
		return _LightPos;
		#else
		return LightPos;
		#endif
	}
	
	float3 getDirection(MATERIAL_INFOS material_infos)
	{
		return getPosition(material_infos) - material_infos.position;
	}
	
	float4 getAmbient()
	{
		#ifdef IN_FXCOMPOSER2
		return _LightAmbient;
		#else
		return LightAmbient;
		#endif
	}
	
	float4 getDiffuse()
	{
		#ifdef IN_FXCOMPOSER2
		return _LightDiffuse;
		#else
		return LightDiffuse;
		#endif
	}
	
	float4 getSpecular()
	{
		#ifdef IN_FXCOMPOSER2
		return _LightSpecular;
		#else
		return LightSpecular;
		#endif
	}
	
	LIGHT_RESULT compute(MATERIAL_INFOS material_infos)
	{
		LIGHT_RESULT light_result = (LIGHT_RESULT)0;
		
		light_result.contribution = float4(1.0f,1.0f,1.0f,1.0f);
		
		
		/* Axial Falloff */
		if(LightAxialFalloffConstant <1.0f)
		{
			float distance = length(getDirection(material_infos));
			
			float d = max(distance-LightAxialFalloffStart,0.0f);
			d /= max(LightAxialFalloffEnd - distance,0.001f);
			float axialFalloff = 1.0f/(1.0f + LightAxialFalloffLinear*d + LightAxialFalloffQuadratic*d*d);
			
			light_result.contribution *= axialFalloff;
		}
		
		
		return light_result;
	}
};

struct SLightSpot : Light
{
	const float3 LightPos;
	const float3 LightDir;
	const float3 LightUp;
	const float3 LightRight;
	
	const float4 LightAmbient;
	const float4 LightDiffuse;
	const float4 LightSpecular;
	
	const float LightAxialFalloffStart;
	const float LightAxialFalloffEnd;
	const float LightAxialFalloffConstant;
	const float LightAxialFalloffLinear;
	const float LightAxialFalloffQuadratic;
	
	const float LightRadialInnerCone; /* cosf(InnerConeAngle * 3.14159f / 180.0f) */
	const float LightRadialOuterCone; /* cosf(OuterConeAngle * 3.14159f / 180.0f) */
	const float LightRadialFalloffExponent;
	
	const float LightAreaType;
	const float LightAreaStatus;
	const float2 LightAreaGeometry;
	
	
	float3 getPosition(MATERIAL_INFOS material_infos)
	{
		return LightPos;
	}
	
	float3 getDirection(MATERIAL_INFOS material_infos)
	{
		return getPosition(material_infos) - material_infos.position;
	}
	
	float4 getAmbient()
	{
		return LightAmbient;
	}
	
	float4 getDiffuse()
	{
		return LightDiffuse;
	}
	
	float4 getSpecular()
	{
		return LightSpecular;
	}
	
	LIGHT_RESULT compute(MATERIAL_INFOS material_infos)
	{
		LIGHT_RESULT light_result = (LIGHT_RESULT)0;
		
		light_result.contribution = float4(1.0f,1.0f,1.0f,1.0f);
		
		
		/* Radial Falloff */
		float3 normal = material_infos.normal;
		float3 direction = normalize(getDirection(material_infos));
		
		float lightAngle = dot(direction,normalize(-LightDir));
		lightAngle = clamp(lightAngle,0.0f,1.0f);
		
		float t = lightAngle + (1.0f-LightRadialInnerCone) - LightRadialOuterCone;
		t = clamp(t/(1.0f-LightRadialOuterCone),0.0f,1.0f);
		
		float radialFalloff = clamp((3.0f*t*t*(1.0f-t) + t*t*t),0.0f,1.0f);
		radialFalloff = pow(radialFalloff,LightRadialFalloffExponent);
		
		light_result.contribution *= radialFalloff;
		
		
		/* Axial Falloff */
		if(LightAxialFalloffConstant <1.0f)
		{
			float distance = length(getDirection(material_infos));
			
			float d = max(distance-LightAxialFalloffStart,0.0f);
			d /= max(LightAxialFalloffEnd - distance,0.001f);
			float axialFalloff = 1.0f/(1.0f + LightAxialFalloffLinear*d + LightAxialFalloffQuadratic*d*d);
			
			light_result.contribution *= axialFalloff;
		}
		
		
		return light_result;
	}
};


/******************************************************************/
/* MATERIAL - "UN-TWEAKABLE" PARAMETERS */
/******************************************************************/

/* Lights interface
 * 
 * Functions :
 * float3 getPosition(MATERIAL_INFOS)
 * float3 getDirection(MATERIAL_INFOS)
 * float4 getAmbient()
 * float4 getDiffuse()
 * float4 getSpecular()
 * LIGHT_RESULT compute(MATERIAL_INFOS)
 * 
 */
#ifdef IN_FXCOMPOSER2
SLightPoint lights[1];
#else
Light lights[];
#endif


/* Matrix transformations */
float4x4 World : World;
float4x4 WorldIT : WorldIT;
float4x4 View : View;
float4x4 ViewIT : ViewIT;
float4x4 Wvp : WorldViewProjection;

/* Uncomment the line below if tangent and binormal of the surface are needed */
int NeedTandB = 1;

/* Global Ambient */
float4 GlobalAmbientColor : GLOBALAMBIENTCOLOR;


/******************************************************************/
/* MATERIAL - TWEAKABLE PARAMETERS */
/******************************************************************/

/* Ambient parameters */
float AmbientStrength
<
	float UIMin = 0.0f;
	float UIMax = 20.0f;
> = 0.0f;

float4 AmbientColor : Ambient
<
	string Desc = "Ambient color";
> = {0.0f,0.0f,0.0f,1.0f};


/* Diffuse parameters */
float DiffuseStrength
<
	float UIMin = 0.0f;
	float UIMax = 20.0f;
> = 1.0f;

float4 DiffuseColor : Diffuse
<
	string Desc = "Diffuse color";
> = {0.15f,0.15f,0.15f,1.0f};

float DiffusePower
<
	float UIMin = 0.0f;
	float UIMax = 250.0f;
> = 5.0f;

float DiffuseBlend
<
	float UIMin = 0.0f;
	float UIMax = 1.0f;
> = 0.15f;

float DiffuseBumpHeight
<
	float UIMin = 0.0f;
	float UIMax = 50.0f;
> = 0.2f;

float DiffuseScale
<
  float UIMin = 0.0f;
  float UIMax = 100.0f;
> = 2.0f;

float DiffuseRatio
<
  float UIMin = 0.0f;
  float UIMax = 100.0f;
> = 1.0f;


/* Specular parameters */
float SpecularStrength
<
	float UIMin = 0.0f;
	float UIMax = 20.0f;
> = 0.3f;

float4 SpecularColor : Specular
<
	string Desc = "Specular color";
> = {1.0f,1.0f,1.0f,1.0f};

float SpecularPower
<
	float UIMin = 0.0f;
	float UIMax = 250.0f;
> = 7.0f;


/* BRDF Effect parameters */
float BRDFStrength
<
	float UIMin = 0.0f;
	float UIMax = 20.0f;
> = 1.0f;

float4 BRDFColor
<
	string Desc = "BRDF Color";
> = {0.137f,0.137f,0.2f,1.0f};

float BRDFPower
<
	float UIMin = 0.0f;
	float UIMax = 250.0f;
> = 4.0f;


/* Bump parameters */
float BumpHeight
<
	float UIMin = 0.0f;
	float UIMax = 50.0f;
> = 0.1f;

float BumpScale
<
  float UIMin = 0.0f;
  float UIMax = 100.0f;
> = 0.1f;

float BumpRatio
<
  float UIMin = 0.0f;
  float UIMax = 100.0f;
> = 1.0f;


/******************************************************************/
/* MATERIAL - TEXTURES */
/******************************************************************/

texture NormalDiffuseTexture
<
	string UIName = "2D Normal Diffuse Map";
	string ResourceName = "CATIA_Normal_2DMap_Leather_1024.dds";
	string ResourceType = "2D";
>;

sampler2D NormalDiffuse2DMap
<
	string File = "CATIA_Normal_2DMap_Leather_1024.dds";
> = sampler_state
{
	Texture = <NormalDiffuseTexture>;
	MinFilter = LinearMipMapLinear; 
	MagFilter = Linear;
};

texture NormalTexture
<
	string UIName = "2D Normal Map";
	string ResourceName = "CATIA_Normal_2DMap_Noisemm_1024.dds";
	string ResourceType = "2D";
>;

sampler2D Normal2DMap
<
	string File = "CATIA_Normal_2DMap_Noisemm_1024.dds";
> = sampler_state
{
	Texture = <NormalTexture>;
	MinFilter = LinearMipMapLinear; 
	MagFilter = Linear;
};


/******************************************************************/
/* MATERIAL - ILLUMINATION FUNCTION */
/******************************************************************/

/* Lafortune illumination model */
ILLUMINATION_RESULT compute(LIGHT_INFOS light_infos,MATERIAL_INFOS material_infos,
	CAMERA_INFOS camera_infos,LIGHT_RESULT light_result)
{
	ILLUMINATION_RESULT result = (ILLUMINATION_RESULT)0;
	
	/* Lobe shape */
	float diffuseLobeShape = (dot(light_infos.direction,material_infos.normal)+1.0f)/2.0f;
	float specularLobeShape = (dot(-reflect(light_infos.direction,material_infos.normal),
		camera_infos.direction)+1.0f)/2.0f;
	
	/* Lobe attenuation */
	diffuseLobeShape = pow(diffuseLobeShape,DiffusePower);
	specularLobeShape = pow(specularLobeShape,SpecularPower);
	
	/* Lobe normalization */
	diffuseLobeShape *= DiffusePower/(2.0f*3.14f) + 1.0f/3.14f;
	specularLobeShape *= SpecularPower/(2.0f*3.14f) + 1.0f/3.14f;
	
	/* Add lobe contribution */
	result.ambient = light_result.contribution*light_infos.ambient;
	result.diffuse = light_result.contribution*light_infos.diffuse*diffuseLobeShape;
	result.specular = light_result.contribution*light_infos.specular*specularLobeShape;
	
	
	return result;
}


/******************************************************************/
/* MATERIAL - FUNCTIONS */
/******************************************************************/

/* BRDF effect */
float getBRDFEffect(float3 normal,
	float3 light,
	float3 camera,
	float BRDFPower,
	float OldBRDFEffect)
{
	float BRDFEffect = OldBRDFEffect;
	
	/* Lobe shape */
	float lshape = (dot(-reflect(light,normal),camera)+1.0f)/2.0f;
	
	/* Lobe exponent */
	lshape = pow(lshape,BRDFPower);
	
	/* Lobe normalization */
	lshape *= BRDFPower/(2.0f*3.14f) + 1.0f/3.14f;
	
	/* add Lobe contribution */
	BRDFEffect += lshape;
	
	return BRDFEffect;
}


/******************************************************************/
/* MATERIAL - VERTEX & FRAGMENT STRUCTURES */
/******************************************************************/

struct Application2Vertex
{
	float3 position : POSITION;
	float4 uv : TEXCOORD0;
	float4 normal : NORMAL;
	float4 tangent : TEXCOORD1;
	float4 binormal	: TEXCOORD2;
};

struct Vertex2Fragment
{
	float4 screenPosition : POSITION;
	float2 uv : TEXCOORD0;
	float3 worldPosition : TEXCOORD1;
	float3 worldNormal : TEXCOORD2;
	float3 worldTangent : TEXCOORD3;
	float3 worldBinormal : TEXCOORD4;
	float3 worldEye : TEXCOORD5;
};


/******************************************************************/
/* MATERIAL - VERTEX & FRAGMENT PROGRAMS */
/******************************************************************/

/* Basic Vertex Program */
Vertex2Fragment BasicVP(Application2Vertex IN)
{
	Vertex2Fragment OUT = (Vertex2Fragment)0;
	
	float4 position = float4(IN.position.xyz,1.0f);
	OUT.screenPosition = mul(Wvp,position); 
	
	OUT.uv = IN.uv.xy;
	
	float3 worldPosition = mul(World,position).xyz;
	OUT.worldPosition= worldPosition;
	
	OUT.worldNormal = normalize(mul(WorldIT,IN.normal)).xyz;
	OUT.worldTangent = normalize(mul(WorldIT,IN.tangent)).xyz;
	OUT.worldBinormal = normalize(mul(WorldIT,IN.binormal)).xyz;
	
	OUT.worldEye = ViewIT[3].xyz;
	
	return OUT;
}

/* Leather BRDF Fragment Program */
float4 LeatherBRDFFP(Vertex2Fragment IN,float vf : FACE) : COLOR
{
	/* Vertex input */
	float3 position = IN.worldPosition;
	float2 uv = IN.uv;
	float3 normal = normalize(IN.worldNormal);
	float3 tangent = normalize(IN.worldTangent);
	float3 binormal = normalize(IN.worldBinormal);
	float3 eye = IN.worldEye;
	
	/* Camera information */
	CAMERA_INFOS camera_infos = (CAMERA_INFOS)0;
	camera_infos.position = eye;
	camera_infos.direction = normalize(eye-position);
	
	/* Normal orientation */
	if(vf < 0.0f) normal = -normal;

	
	/* Normal modification */
	float4 normalLeatherColor = tex2D(NormalDiffuse2DMap,
		float2(uv.x*DiffuseScale,uv.y*DiffuseScale*DiffuseRatio));
	float2 leatherBump = DiffuseBumpHeight*normalLeatherColor.a*(normalLeatherColor.xy - (0.5f).xx);
	
	float4 normalColor = tex2D(Normal2DMap,float2(uv.x*BumpScale,uv.y*BumpScale*BumpRatio));
	float2 bump = BumpHeight*normalColor.a*(normalColor.xy - (0.5f).xx);
	
	normal += tangent*leatherBump.x + binormal*leatherBump.y;
	normal += tangent*bump.x + binormal*bump.y;
	normal = normalize(normal);
	
	
	/* Material information */
	MATERIAL_INFOS material_infos = (MATERIAL_INFOS)0;
	material_infos.position = position;
	material_infos.normal = normal;
	material_infos.tangent = tangent;
	material_infos.binormal = binormal;
	
	
	/* Lighting result */
	LIGHT_INFOS light_infos = (LIGHT_INFOS)0;
	LIGHT_RESULT light_result = (LIGHT_RESULT)0;
	ILLUMINATION_RESULT illumination_result = (ILLUMINATION_RESULT)0;
	illumination_result.ambient += GlobalAmbientColor;
	
	float brdf = 0.0f;
	for(int i=0; i<lights.length; i++)
	{
		/* Light information */
		light_infos.position = lights[i].getPosition(material_infos);
		light_infos.direction = normalize(lights[i].getDirection(material_infos));
		light_infos.ambient = lights[i].getAmbient();
		light_infos.diffuse = lights[i].getDiffuse();
		light_infos.specular = lights[i].getSpecular();
		
		/* Light computation */
		light_result = lights[i].compute(material_infos);
		
		/* Illumination computation */
		ILLUMINATION_RESULT ir = compute(light_infos,material_infos,camera_infos,light_result);
		illumination_result.ambient += ir.ambient;
		illumination_result.diffuse += ir.diffuse;
		illumination_result.specular += ir.specular;
		
		brdf = getBRDFEffect(material_infos.normal,light_infos.direction,camera_infos.direction,
			BRDFPower,brdf);
	}
	
	/* Leather */
	float4 leatherColor = float4(normalLeatherColor.zzz,1.0f);
	
	/* Leather blend */
	DiffuseBlend = clamp(DiffuseBlend,0.0f,1.0f);
	leatherColor = DiffuseBlend*leatherColor
		+ max(1.0f-DiffuseBlend,0.0f)*float4(1.0f,1.0f,1.0f,1.0f);
	
	
	/* Material result */
	float4 result = (float4)0;
	
	/* Basic contribution */
	result += illumination_result.ambient*(AmbientStrength*AmbientColor);
	result += illumination_result.diffuse*(DiffuseStrength*DiffuseColor);
	result += illumination_result.specular*(SpecularStrength*SpecularColor);
	
	/* BRDF contribution */
	result += illumination_result.diffuse*(BRDFStrength*BRDFColor);
	
	/* Leather contribution */
	result *= leatherColor;
	
	
	return float4(result.xyz,1.0f);
}


/******************************************************************/
/* MATERIAL - TECHNIQUES */
/******************************************************************/

technique LeatherBRDF
{
	pass p0
	{
		/* Uncomment the line below to show stickers correctly */
		PolygonOffset = float2(2.0,2.0);
		
		DepthTestEnable=true;
		DepthMask = true;
		DepthFunc = LEqual;
		
		/* Uncomment the line(s) below to enable transparency */
		//BlendEnable = true;
		#ifdef IN_FXCOMPOSER2
		//BlendFunc = int2(SrcAlpha, One);
		#endif
		
		
		VertexProgram = compile vp40 BasicVP();
		
		FragmentProgram = compile fp40 LeatherBRDFFP();
	}
}
technique LeatherBRDFGLSL
{
	pass p0
	{
		/* Uncomment the line below to show stickers correctly */
		PolygonOffset = float2(2.0,2.0);
		
		DepthTestEnable=true;
		DepthMask = true;
		DepthFunc = LEqual;
		
		/* Uncomment the line(s) below to enable transparency */
		//BlendEnable = true;
		#ifdef IN_FXCOMPOSER2
		//BlendFunc = int2(SrcAlpha, One);
		#endif
		
		
		VertexProgram = compile glslv BasicVP();
		
		FragmentProgram = compile glslf LeatherBRDFFP();
	}
}

