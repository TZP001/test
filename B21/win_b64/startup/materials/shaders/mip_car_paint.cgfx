/******************************************************************************
 * The following code was generated by the mental mill(R)                     *
 *                                                                            *
 * Copyright 1986-2007 by mental images GmbH, Fasanenstr. 81, D-10623         *
 * Berlin, Germany. All rights reserved.                                      *
******************************************************************************/

//
// The state structure is used internally within the fragment shader to
// commonly used values.
//
struct State
{
	float4 tex_coord[4];
	float3 tangent[1];
	float3 binormal[1];
	float3 tex_du[1];
	float3 tex_dv[1];
	float3 position;
	float3 normal;
	float3 geom_normal;
	float3 motion;
	float2 raster;
	bool backside;
	float3 direction;
	float ray_length;
	float dot_nd;
	float3x3 tangent_space[1];
	float importance;
	float4 volume_input;
	float3 light_position;
	float3 light_direction;
	float3 light_to_surface;
	float light_distance;
	float light_dotnl;
	int light_type;
	float light_spread;
	float light_spread_cos;
	float light_distance_limit;
};

//
// Values for the light_type parameter of light shaders
//
#define LIGHT_POINT    0
#define LIGHT_SPOT     1
#define LIGHT_INFINITE 2
#define LIGHT_PLANAR   3

//
// The light iterator structure holds the return values resulting from
// evaluating a light.
//
struct Light_iterator {
	float3 _point;
	float4 contribution;
	float4 raw_contribution;
	float  dot_nl;
	float3 direction;
	float  distance;
	float4 shadow;
	int    count;
};

struct Ray {
	float3 origin;
	float3 direction;
};

//
// The light interface defines a method used to evaluate different types
// of lights. Light shaders are generated as structs which implement this
// interface.
//
interface Light {
	Light_iterator eval(State state);
};

void __make_basis(const float3 n, const float3 u, const float3 v,
        out float3 t, out float3 b)
{
    b = normalize(cross(u,n));
    t = cross(n,b);
    if (dot(b,v) < 0.0)  b = -b;
}

float3 __perspective_divide(float4 pt)
{
    return pt.xyz/pt.w;
}

//
// The following are free parameters of the shader that should be set by the
// application at runtime.
//
texture __Environment_map_cubic_1_env_tex <
	string UIName = "Environment_map_cubic_1_env_tex";
	//string ResourceName = "CATRmaCptCUBEReflectionMapSkyCube.dds";
	string ResourceName = "CATRmaCpt_Environment_CUBEMap_Hall_1024.dds";
	string ResourceType = "Cube";
>;

samplerCUBE Environment_map_cubic_1_env_tex
<
	string File = "CATRmaCpt_Environment_CUBEMap_Hall_1024.dds";
> = sampler_state {
	Texture = <__Environment_map_cubic_1_env_tex>;
	MinFilter = LinearMipMapLinear;
	MagFilter = Linear;
	WrapR = ClampToEdge;
	WrapS = ClampToEdge;
	WrapT = ClampToEdge;
};

float Environment_map_cubic_1_intensity
<
	string UIName = "Intensity";
	float UIMin = 0.000000;
	float UIMax = 10.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 1.000000;
float4 ambient
<
	string UIName = "Ambient color";
	string UIWidget = "Color";
> = float4(0.000000, 0.000000, 0.000000, 1.000000);
float4 base_color
<
	string UIName = "Base color ";
	string UIWidget = "Color";
> = float4(0.800000, 0.100000, 0.000000, 1.000000);
float4 edge_color
<
	string UIName = "Edge tone color ";
	string UIWidget = "Color";
> = float4(0.600000, 0.070000, 0.070000, 1.000000);
float edge_color_bias
<
	string UIName = "Edge tone bias ";
	string UIWidget = "slider";
	float UIMin = 0;
	float UIMax = 1;
	float UIStep = 0.01;
> = 1.000000;
float4 lit_color
<
	string UIName = "Light tone color";
	string UIWidget = "Color";
> = float4(0.830000, 0.030000, 0.110000, 1.000000);
float lit_color_bias
<
	string UIName = "Light tone bias";
	string UIWidget = "slider";
	float UIMin = 0;
	float UIMax = 1;
	float UIStep = 0.01;
> = 8.000000;
float diffuse_weight
<
	string UIName = "Diffuse weight ";
	string UIWidget = "slider";
	float UIMin = 0;
	float UIMax = 1;
	float UIStep = 0.01;
> = 1.000000;
float diffuse_bias
<
	string UIName = "Diffuse bias ";
	string UIWidget = "slider";
	float UIMin = 0;
	float UIMax = 1;
	float UIStep = 0.01;
> = 1.500000;
float irradiance_weight
<
	string UIName = "Irradiance weight ";
	string UIWidget = "slider";
	float UIMin = 0;
	float UIMax = 1;
	float UIStep = 0.01;
> = 1.000000;
float4 spec
<
	string UIName = "Specular_1 color ";
	string UIWidget = "Color";
> = float4(1.000000, 1.000000, 1.000000, 1.000000);
float spec_weight
<
	string UIName = "Specular_1 weight ";
	string UIWidget = "slider";
	float UIMin = 0;
	float UIMax = 1;
	float UIStep = 0.01;
> = 0.200000;
float spec_exp
<
	string UIName = "Specular_1 Exponent ";
	float UIMin = 30.000000;
	float UIMax = 250.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 60.000000;
float4 spec_sec
<
	string UIName = "Specular_2 Color ";
	string UIWidget = "Color";
> = float4(1.000000, 1.000000, 1.000000, 1.000000);
float spec_sec_weight
<
	string UIName = "Specular_2 weight ";
	string UIWidget = "slider";
	float UIMin = 0;
	float UIMax = 1;
	float UIStep = 0.01;
> = 0.300000;
float spec_sec_exp
<
	string UIName = "Specular2 exponent ";
	float UIMin = 10.000000;
	float UIMax = 50.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 25.000000;
bool spec_glazing
<
	string UIName = "Specular glazing ";
> = true;
float4 flake_color
<
	string UIName = "Flake Color";
	string UIWidget = "Color";
> = float4(1.000000, 1.000000, 1.000000, 1.000000);
float flake_weight
<
	string UIName = "Flake weight";
	string UIWidget = "slider";
	float UIMin = 0;
	float UIMax = 1;
	float UIStep = 0.01;
> = 1.000000;
float flake_reflect
<
	string UIName = "Flake Reflect";
	string UIWidget = "slider";
	float UIMin = 0;
	float UIMax = 1;
	float UIStep = 0.01;
> = 0.000000;
float flake_exp
<
	string UIName = "Flake exponent";
	string UIWidget = "slider";
	float UIMin = 0;
	float UIMax = 1;
	float UIStep = 0.01;
> = 45.000000;
float flake_decay
<
	string UIName = "Flake decay";
	string UIWidget = "slider";
	float UIMin = 0;
	float UIMax = 1;
	float UIStep = 0.01;
> = 0.000000;
int flake_bump = 0;
float global_weight
<
	string UIName = "Global weight";
	string UIWidget = "slider";
	float UIMin = 0;
	float UIMax = 1;
	float UIStep = 0.01;
> = 1.000000;
int mode = 0;
float flake_density
<
	string UIName = "Flake density";
	string UIWidget = "slider";
	float UIMin = 0;
	float UIMax = 1;
	float UIStep = 0.01;
> = 0.500000;
float flake_strength
<
	string UIName = "Flake strength";
	string UIWidget = "slider";
	float UIMin = 0;
	float UIMax = 1;
	float UIStep = 0.01;
> = 0.800000;
float flake_scale
<
	string UIName = "flake scale";
	string UIWidget = "slider";
	float UIMin = 0;
	float UIMax = 1;
	float UIStep = 0.01;
> = 0.04000;
texture __noise_random_texture <
	string UIName = "noise_random_texture";
	string ResourceName = "noise_rtable.dds";
	string ResourceType = "2D";
>;

sampler2D noise_random_texture
<
	string File = "noise_rtable.dds";
> = sampler_state {
	Texture = <__noise_random_texture>;
	MinFilter = Nearest;
	MagFilter = Nearest;
};

texture __noise_corr_texture <
	string UIName = "noise_corr_texture";
	string ResourceName = "noise_correction.dds";
	string ResourceType = "1D";
>;

sampler1D noise_corr_texture
<
	string File = "noise_correction.dds";
> = sampler_state {
	Texture = <__noise_corr_texture>;
	MinFilter = Nearest;
	MagFilter = Nearest;
};



//
// The following are parameters representing non-varying state variables 
// referenced by the shader. These should be set by the application at runtime.
// Note that vector parameters should be provided in camera space.
//
#ifndef __OBJECT_TO_NDC
#define __OBJECT_TO_NDC
float4x4 __object_to_ndc : WorldViewProjection
<
	string UIWidget = "none";
>;
#endif
#ifndef __REFRACTED_IOR
#define __REFRACTED_IOR
float __refracted_ior = 1.01;
#endif
#ifndef __INCIDENT_IOR
#define __INCIDENT_IOR
float __incident_ior = 1.0;
#endif
#ifndef __ORTHOGRAPHIC
#define __ORTHOGRAPHIC
bool __orthographic = false;
#endif
#ifndef __OBJECT_TO_CAMERA
#define __OBJECT_TO_CAMERA
float4x4 __object_to_camera : WorldView
<
	string UIWidget = "none";
>;
#endif
#ifndef __CAMERA_TO_WORLD
#define __CAMERA_TO_WORLD
float4x4 __camera_to_world : ViewI
<
	string UIWidget = "none";
>;
#endif
#ifndef __CAMERA_TO_OBJECT
#define __CAMERA_TO_OBJECT
float4x4 __camera_to_object : WorldViewI
<
	string UIWidget = "none";
>;
#endif
#ifndef SCENE_AMBIENT
#define SCENE_AMBIENT
float4 __scene_ambient = float4(0.00,0.00,0.00,0.00);
#endif

//
// The following array represents the attachment points to lights.
// The application should use the Cg runtime to create instances of
// light of shaders and attach them before final compilation with
// the Cg compiler.
//
Light lights[];
#ifndef X0000277__Scalar__Texture2d__Int__Int__Int
#define X0000277__Scalar__Texture2d__Int__Int__Int 1
float X0000277(
	sampler2D X0000000,
	int X0000001,
	int X0000002,
	int X0000003)
{
	float X0000004 = 0x8000;
	float X0000005;
	float X0000006;
	float X0000007;
	float X0000008;
	X0000006 = (((float(X0000001)) / X0000004) * 1341.0);
	X0000007 = (((float(X0000002)) / X0000004) * 719.0);
	X0000008 = (((float(X0000003)) / X0000004) * 2031.0);
	X0000005 = ((X0000006 + X0000007) + X0000008);
	float X0000009;
	float X0000010;
	X0000009 = (floor(X0000005));
	X0000010 = (X0000005 - X0000009);
	X0000005 = (X0000010 * X0000004);
	float2 X0000011;
	X0000011 = (float2(((floor((fmod(X0000005, (float(0x100)))))) / 0x100), ((floor((X0000005 / (float(0x100))))) / 0x80)));
	X0000011.x = (((X0000011.x * (float((0x100 - 1)))) / (float(0x100))) + (0.5 / (float(0x100))));
	X0000011.y = (((X0000011.y * (float((0x80 - 1)))) / (float(0x80))) + (0.5 / (float(0x80))));
	return (tex2D(X0000000, X0000011, (float2(0, 0)), (float2(0, 0)))).x;
}
#endif

#ifndef X0000278__Scalar__Texture2d__Texture1d__Int__Int__Bool__Bool__Scalar__Scalar__Scalar__Scalar____Scalar____Scalar__
#define X0000278__Scalar__Texture2d__Texture1d__Int__Int__Bool__Bool__Scalar__Scalar__Scalar__Scalar____Scalar____Scalar__ 1
float X0000278(
	sampler2D X0000012,
	sampler1D X0000013,
	int X0000014,
	int X0000015,
	bool X0000016,
	bool X0000017,
	float X0000018,
	float X0000019,
	float X0000020,
	out float X0000021,
	out float X0000022,
	out float X0000023)
{
	float X0000024;
	X0000024 = 0.5;
	int X0000025;
	int X0000026;
	int X0000027;
	int X0000028;
	int X0000029;
	int X0000030;
	int X0000031;
	int X0000032;
	int X0000033;
	int X0000034;
	int X0000035 = 3;
	float X0000036;
	float X0000037;
	float X0000038;
	float X0000039[9];
	float X0000040[9];
	float X0000041[3];
	float X0000042[27];
	float X0000043[9];
	float X0000044[3];
	float X0000045[9];
	float X0000046[3];
	float X0000047[3];
	float X0000048;
	float X0000049;
	float X0000050;
	if (X0000018 < (-39999))
	{
		X0000018 = ((-39998) - X0000018);
	}
	else
	{
		X0000018 += 40000;
	}
	if (X0000019 < (-39999))
	{
		X0000019 = ((-39998) - X0000019);
	}
	else
	{
		X0000019 += 40000;
	}
	if (X0000020 < (-39999))
	{
		X0000020 = ((-39998) - X0000020);
	}
	else
	{
		X0000020 += 40000;
	}
	if (X0000014 == 2)
	{
		X0000028 = (int((X0000036 = (X0000018 - .5))));
		X0000029 = (int((X0000037 = (X0000019 - .5))));
		X0000030 = (int((X0000038 = (X0000020 - .5))));
	}
	else
	{
		X0000028 = (int((X0000036 = X0000018)));
		X0000029 = (int((X0000037 = X0000019)));
		X0000030 = (int((X0000038 = X0000020)));
	}
	X0000041[0] = (X0000036 - X0000028);
	X0000041[1] = (X0000037 - X0000029);
	X0000041[2] = (X0000038 - X0000030);
	if (X0000014 == 2)
	{
		X0000031 = 3;
	}
	else
	{
		X0000031 = 2;
	}
	X0000032 = X0000031;
	if (X0000015 >= 2)
	{
		X0000033 = X0000031;
	}
	else
	{
		X0000033 = 1;
	}
	if (X0000015 >= 3)
	{
		X0000034 = X0000031;
	}
	else
	{
		X0000034 = 1;
	}
	for (X0000025 = 0; X0000025 < X0000034; (++X0000025), (++X0000030))
	{
		for ((X0000029 = (int(X0000037))), (X0000026 = 0); X0000026 < X0000033; (++X0000026), (++X0000029))
		{
			for ((X0000028 = (int(X0000036))), (X0000027 = 0); X0000027 < X0000032; (++X0000027), (++X0000028))
			{
				X0000042[((((X0000025 * X0000034) + X0000026) * X0000033) + X0000027)] = (X0000277(X0000012, X0000028, X0000029, X0000030));
			}
		}
	}
	for (X0000025 = 0; X0000025 < X0000039.length; X0000025++)
	{
		X0000039[X0000025] = 0;
	}
	for (X0000025 = 0; X0000025 < X0000040.length; X0000025++)
	{
		X0000040[X0000025] = 0;
	}
	if (X0000014 == 2)
	{
		for (X0000025 = 0; X0000025 < X0000015; ++X0000025)
		{
			X0000036 = (1.0 - X0000041[X0000025]);
			X0000039[((0 * X0000035) + X0000025)] = ((X0000036 * X0000036) * .5);
			X0000040[((0 * X0000035) + X0000025)] = (-X0000036);
			X0000036 = (X0000041[X0000025] - .5);
			X0000039[((1 * X0000035) + X0000025)] = (((-X0000036) * X0000036) + .75);
			X0000040[((1 * X0000035) + X0000025)] = ((-2) * X0000036);
			X0000039[((2 * X0000035) + X0000025)] = ((X0000041[X0000025] * X0000041[X0000025]) * .5);
			X0000040[((2 * X0000035) + X0000025)] = X0000041[X0000025];
		}
	}
	else
	{
		for (X0000025 = 0; X0000025 < X0000015; X0000025++)
		{
			X0000039[((1 * X0000035) + X0000025)] = ((X0000041[X0000025] * X0000041[X0000025]) * (((-2) * X0000041[X0000025]) + 3));
			X0000039[((0 * X0000035) + X0000025)] = (1.0 - X0000039[((1 * X0000035) + X0000025)]);
		}
	}
	if (X0000016)
	{
		for ((X0000048 = (X0000049 = (X0000050 = (X0000036 = 0)))), (X0000025 = 0); X0000025 < X0000034; ++X0000025)
		{
			for ((X0000046[X0000025] = (X0000047[X0000025] = (X0000044[X0000025] = 0))), (X0000026 = 0); X0000026 < X0000033; ++X0000026)
			{
				for ((X0000045[((X0000025 * X0000035) + X0000026)] = (X0000043[((X0000025 * X0000035) + X0000026)] = 0)), (X0000027 = 0); X0000027 < X0000032; ++X0000027)
				{
					X0000043[((X0000025 * X0000035) + X0000026)] += (X0000039[((X0000027 * X0000035) + 0)] * X0000042[((((X0000025 * X0000035) + X0000026) * X0000035) + X0000027)]);
					X0000045[((X0000025 * X0000035) + X0000026)] += (X0000040[((X0000027 * X0000035) + 0)] * X0000042[((((X0000025 * X0000035) + X0000026) * X0000035) + X0000027)]);
				}
				if (X0000015 >= 2)
				{
					X0000044[X0000025] += (X0000039[((X0000026 * X0000035) + 1)] * X0000043[((X0000025 * X0000035) + X0000026)]);
					X0000046[X0000025] += (X0000039[((X0000026 * X0000035) + 1)] * X0000045[((X0000025 * X0000035) + X0000026)]);
					X0000047[X0000025] += (X0000040[((X0000026 * X0000035) + 1)] * X0000043[((X0000025 * X0000035) + X0000026)]);
				}
			}
			if (X0000015 >= 3)
			{
				X0000036 += (X0000039[((X0000025 * X0000035) + 2)] * X0000044[X0000025]);
				X0000048 += (X0000039[((X0000025 * X0000035) + 2)] * X0000046[X0000025]);
				X0000049 += (X0000039[((X0000025 * X0000035) + 2)] * X0000047[X0000025]);
				X0000050 += (X0000040[((X0000025 * X0000035) + 2)] * X0000044[X0000025]);
			}
		}
	}
	else
	{
		for ((X0000036 = 0), (X0000025 = 0); X0000025 < X0000034; ++X0000025)
		{
			for ((X0000044[X0000025] = 0), (X0000026 = 0); X0000026 < X0000033; ++X0000026)
			{
				for ((X0000043[((X0000025 * X0000035) + X0000026)] = 0), (X0000027 = 0); X0000027 < X0000032; ++X0000027)
				{
					X0000043[((X0000025 * X0000035) + X0000026)] += (X0000039[((X0000027 * X0000035) + 0)] * X0000042[((((X0000025 * X0000035) + X0000026) * X0000035) + X0000027)]);
				}
				if (X0000015 >= 2)
				{
					X0000044[X0000025] += (X0000039[((X0000026 * X0000035) + 1)] * X0000043[((X0000025 * X0000035) + X0000026)]);
				}
			}
			if (X0000015 >= 3)
			{
				X0000036 += (X0000039[((X0000025 * X0000035) + 2)] * X0000044[X0000025]);
			}
		}
	}
	if (X0000016)
	{
		if (X0000015 == 1)
		{
			X0000021 = X0000045[((0 * X0000035) + 0)];
		}
		if (X0000015 == 2)
		{
			(X0000021 = X0000046[0]), (X0000022 = X0000047[0]);
		}
		if (X0000015 == 3)
		{
			(X0000021 = X0000048), (X0000022 = X0000049), (X0000023 = X0000050);
		}
	}
	X0000024 = ((X0000015 == 1) ? X0000043[((0 * X0000035) + 0)] : ((X0000015 == 2) ? X0000044[0] : X0000036));
	if (X0000017)
	{
		float X0000051;
		float X0000052;
		float X0000053;
		int X0000054 = 128;
		int X0000055 = 64;
		do
		{
			X0000053 = (tex1D(X0000013, (float((X0000054 / 512.0))))).r;
			if (X0000053 >= X0000024)
			{
				X0000054 -= X0000055;
			}
			else
			{
				X0000054 += X0000055;
			}
			X0000055 /= 2;
		}
		while (X0000055 > 0.001);
		X0000053 = (tex1D(X0000013, (float((X0000054 / 512.0))))).r;
		if (X0000053 >= X0000024)
		{
			X0000051 = (tex1D(X0000013, (float(((X0000054 - 1) / 512.0))))).r;
			X0000052 = (tex1D(X0000013, (float((X0000054 / 512.0))))).r;
			X0000024 = (((X0000054 - 1) + ((X0000024 - X0000051) / (X0000052 - X0000051))) / 256.0);
		}
		else
		{
			X0000051 = (tex1D(X0000013, (float((X0000054 / 512.0))))).r;
			X0000052 = (tex1D(X0000013, (float(((X0000054 + 1) / 512.0))))).r;
			X0000024 = ((X0000054 + ((X0000024 - X0000051) / (X0000052 - X0000051))) / 256.0);
		}
	}
	return X0000024;
}
#endif

#ifndef X0000455__Scalar__Texture2d__Texture1d__Vector3__Scalar____Scalar____Scalar__
#define X0000455__Scalar__Texture2d__Texture1d__Vector3__Scalar____Scalar____Scalar__ 1
float X0000455(
	sampler2D X0000093,
	sampler1D X0000094,
	float3 X0000095,
	out float X0000096,
	out float X0000097,
	out float X0000098)
{
	int X0000099 = 2;
	return X0000278(X0000093, X0000094, X0000099, 3, true, false, X0000095.x, X0000095.y, X0000095.z, X0000096, X0000097, X0000098);
}
#endif


//
// The App2vert structure defines the vertex attributes used by the vertex
// shader. The application should supply a vertex stream containing these 
// elements.
//
struct App2vert
{
	float3 position : POSITION;
	float3 normal : NORMAL;
};

//
// The Vert2frag structure defines values used by the fragment shader and
// supplied by the vertex shader.
//
struct Vert2frag
{
	float4 hpos : POSITION;
	float3 position : TEXCOORD0;
	float3 normal : TEXCOORD1;
	float4 fcolor : COLOR0;
	float4 bcolor : BCOL0;
};

//
// This function is the main method of the vertex shader.
//
Vert2frag vertex_main(
	App2vert vs_in)
{
	Vert2frag vs_out;
	float4 position = float4(vs_in.position, 1);
	vs_out.hpos = mul(__object_to_ndc, position);
	vs_out.position = mul(__object_to_camera, position).xyz;
	vs_out.normal = mul(vs_in.normal, (float3x3)__camera_to_object);
	vs_out.fcolor = float4(1,0,0,0);
	vs_out.bcolor = float4(0,0,0,0);
	return vs_out;
}

//
// The following functions are generated from the MetaSL implementation of
// the shaders that are part of the compiled shader graph.
//

void Environment_map_cubic_main(
	samplerCUBE env_tex,
	float intensity,
	State state,
	out float4 __local_result)
{
	{
		float3 v = mul(((float3x3 )(__camera_to_world)), (state.direction));
		__local_result = (texCUBE(env_tex, v.xyz));
		__local_result *= intensity;
	}
}

void Environment_map_cubic_1_main(
	State state,
	out float4 result)
{
	{
		Environment_map_cubic_main(Environment_map_cubic_1_env_tex, Environment_map_cubic_1_intensity, (state), result);
	}
}

float4 __reflect_environment(
	State state)
{
	(state.direction) = (reflect((state.position), (state.normal)));
	float4 result;
	Environment_map_cubic_1_main((state), result);
	return result;
}

float4 __refract_environment(
	State state)
{
	(state.direction) = (refract((state.position), (state.normal), ((__refracted_ior) / (__incident_ior))));
	float4 result;
	Environment_map_cubic_1_main((state), result);
	return result;
}

float4 __trace_environment(
	State state,
	Ray ray)
{
	(state.position) = ray.origin;
	(state.direction) = ray.direction;
	float4 result;
	Environment_map_cubic_1_main((state), result);
	return result;
}

float X0000180_mi_metallic_paint_flakes(
	float3 X0000182,
	float3 X0000183,
	float3 X0000184,
	float X0000185)
{
	float X0000186 = 0.0;
	float3 X0000187 = X0000182 - X0000183;
	float X0000188 = dot(X0000187, X0000184);
	X0000188 *= (X0000188 / (dot(X0000187, X0000187)));
	if (X0000188 > 0.0)
	{
		X0000186 = (exp((((log(X0000188)) * 0.5) * X0000185)));
	}
	return X0000186;
}

float X0000181_mi_metallic_paint_flakes(
	float X0000189,
	float X0000190,
	float X0000191)
{
	float X0000192;
	float X0000193;
	if (X0000191 <= X0000189)
	{
		X0000193 = 0.0;
	}
	else
	{
		if (X0000191 >= X0000190)
		{
			X0000193 = 1.0;
		}
		else
		{
			X0000192 = ((X0000191 - X0000189) / (X0000190 - X0000189));
			X0000193 = ((X0000192 * X0000192) * (3.0 - (2.0 * X0000192)));
		}
	}
	return X0000193;
}

void mi_metallic_paint_flakes_main(
	float4 ambient,
	float4 base_color,
	float4 edge_color,
	float edge_color_bias,
	float4 lit_color,
	float lit_color_bias,
	float diffuse_weight,
	float diffuse_bias,
	float irradiance_weight,
	float4 spec,
	float spec_weight,
	float spec_exp,
	float4 spec_sec,
	float spec_sec_weight,
	float spec_sec_exp,
	bool spec_glazing,
	float4 flake_color,
	float flake_weight,
	float flake_reflect,
	float flake_exp,
	float flake_decay,
	int flake_bump,
	float global_weight,
	int mode,
	float flake_density,
	float flake_strength,
	float flake_scale,
	sampler2D noise_random_texture,
	sampler1D noise_corr_texture,
	State state,
	out float4 result)
{
	{
		float X0000194 = 3.1415926535897932384626433832795;
		float X0000195 = irradiance_weight / X0000194;
		float X0000196 = flake_decay;
		float X0000197 = flake_density;
		float X0000198 = flake_scale;
		float4 X0000199;
		float X0000200 = flake_reflect;
		bool X0000201;
		float X0000202 = flake_weight;
		float X0000203 = global_weight;
		float X0000204 = spec_weight;
		float X0000205 = spec_sec_exp;
		float X0000206 = diffuse_bias;
		if (flake_weight > 0.0)
		{
			X0000201 = true;
		}
		else
		{
			X0000201 = false;
		}
		float X0000207;
		float X0000208;
		float X0000209;
		float X0000210;
		float4 X0000211;
		float4 X0000212;
		float3 X0000213;
		float3 X0000214;
		float3 X0000215;
		float X0000216;
		float X0000217;
		float X0000218;
		if (X0000203 <= 0.0)
		{
			X0000203 = 1.0;
		}
		if (spec_exp <= 0.0)
		{
			X0000204 = 0.0;
		}
		if (spec_sec_exp <= 0)
		{
			X0000205 = 0.0f;
		}
		if (X0000206 < 0)
		{
			X0000206 = 0.0f;
		}
		X0000214 = (mul((__camera_to_object), (float4((state.position), 1.0)))).xyz;
		X0000215 = (mul((__camera_to_object), (float4((state.position), 1.0)))).xyz;
		X0000215 -= X0000214;
		X0000216 = (((X0000215.x * X0000215.x) + (X0000215.y * X0000215.y)) + (X0000215.z * X0000215.z));
		X0000215 = (normalize(X0000215));
		if ((__orthographic) == true)
		{
			X0000196 = 0.0;
		}
		if (edge_color_bias > 0.0)
		{
			X0000217 = (abs((dot((state.normal), (state.direction)))));
			X0000217 = (pow(X0000217, edge_color_bias));
			X0000218 = (1.0 - X0000217);
			X0000212 = ((base_color * X0000217) + (edge_color * X0000218));
		}
		result = (ambient * X0000212);
		if (X0000201)
		{
			float3 X0000219 = state.normal;
			{
				float3 X0000220;
				float3 X0000221;
				float3 X0000222;
				X0000222 = (mul((__camera_to_object), (float4((state.position), 1.0)))).xyz;
				X0000222 /= flake_scale;
				if (X0000197 <= 0.0)
				{
					X0000197 = 0.5;
				}
				if (X0000198 <= 0.0)
				{
					X0000198 = 0.1;
				}
				X0000455(noise_random_texture, noise_corr_texture, X0000222, X0000208, X0000209, X0000210);
				X0000222 += ((float3(X0000208, X0000209, X0000210)) * 2);
				X0000222 = (floor(X0000222));
				X0000207 = (X0000455(noise_random_texture, noise_corr_texture, X0000222, X0000208, X0000209, X0000210));
				X0000207 = (pow(X0000207, (1.0f / flake_density)));
				X0000220 = (float3(X0000208, X0000209, X0000210));
				X0000221 = (mul(X0000220, (float3x3((__camera_to_object)))));
				(state.normal) += (X0000221 * flake_strength);
				(state.normal) = (normalize((state.normal)));
				X0000199 = (flake_color * X0000207);
			}
			X0000213 = (state.normal);
			(state.normal) = X0000219;
			X0000216 = (1.0 - ((X0000196 > 0.0) ? ((sqrt(X0000216)) / X0000196) : 0.0));
			if (X0000216 < 0.0)
			{
				X0000216 = 0.0;
			}
			X0000202 *= (1.0 - (exp((-X0000216))));
			X0000216 = ((X0000216 * flake_exp) + ((1.0 - X0000216) * spec_exp));
			X0000200 *= X0000202;
			if (X0000200 > 0.0)
			{
				
				Ray X0000224 = Ray((float3(0.0)), (float3(0.0)));
				float3 X0000225;
				(state.normal) = X0000213;
				float3 X0000226 = reflect((state.direction), (state.normal));
				if ((dot(X0000226, (state.geom_normal))) > 0.0)
				{
					;
					Ray X0000227 = Ray((state.position), X0000226);
					if (false)
					{
						X0000211 = ((X0000199 * X0000211) * X0000200);
					}
					else
					{
						X0000211 = ((X0000199 * (__trace_environment((state), X0000227))) * X0000200);
						float4 X0000228 = __trace_environment((state), X0000227);
					}
					result += X0000211;
				}
				(state.normal) = X0000219;
			}
		}
		Light_iterator X0000229;
		float4 X0000230 = float4(0.0, 0.0, 0.0, 1.0);
		float3 X0000231;
		float X0000232;
		float4 X0000233;
		float X0000234;
		for (int light_index=0;
		     light_index < lights.length;
		     light_index++)
		{
			X0000229 = lights[light_index].eval(state); X0000229.count = light_index;
			float4 X0000235 = X0000229.contribution / 3.14159265358979323846f;
			X0000230 = (float4(0.0, 0.0, 0.0, 1.0));
			if (X0000229.dot_nl < 0.0)
			{
				X0000232 = 0;
			}
			else
			{
				X0000232 = X0000229.dot_nl;
			}
			X0000234 = ((pow(X0000232, X0000206)) * diffuse_weight);
			if (lit_color_bias > 0.0)
			{
				X0000217 = (pow(X0000232, lit_color_bias));
				X0000217 *= (abs((dot((state.normal), (state.direction)))));
				X0000218 = (1.0 - X0000217);
				X0000233 = ((X0000212 * X0000218) + (lit_color * X0000217));
			}
			else
			{
				X0000233 = X0000212;
			}
			X0000230 += ((X0000234 * X0000233) * X0000235);
			X0000217 = (pow(X0000232, 0.5f));
			X0000231 = X0000229.direction;
			if (spec_weight > 0.0)
			{
				X0000234 = (X0000180_mi_metallic_paint_flakes(X0000229.direction, (state.direction), (state.normal), spec_exp));
				if (X0000234 > 0.0)
				{
					if (spec_glazing)
					{
						X0000234 = (X0000181_mi_metallic_paint_flakes(0.5, 0.8, X0000234));
					}
					X0000234 *= (spec_weight * X0000217);
					X0000230 += ((X0000234 * spec) * X0000235);
				}
			}
			if (spec_sec_weight > 0.0)
			{
				X0000234 = (((X0000180_mi_metallic_paint_flakes(X0000229.direction, (state.direction), (state.normal), spec_sec_exp)) * spec_sec_weight) * X0000217);
				if (X0000234 > 0.0)
				{
					X0000230 += ((X0000234 * spec_sec) * X0000235);
				}
			}
			if (X0000201)
			{
				float3 X0000236 = float3(0.0, 0.0, 0.0);
				float X0000237 = 0.0;
				X0000236 = X0000231;
				X0000236 -= (state.direction);
				X0000236 = (normalize(X0000236));
				X0000237 = (dot(X0000213, X0000236));
				if (X0000237 > 0.0)
				{
					if (X0000216 < 0.0)
					{
						X0000216 = 0.0;
					}
					X0000237 = ((X0000202 * (pow(X0000237, X0000216))) * X0000217);
					X0000230 += ((X0000207 * X0000237) * X0000235);
				}
			}
			result += X0000230;
		}
		if (X0000195 > 0.0)
		{
			
			result += ((X0000195 * (__scene_ambient)) * X0000212);
		}
		result *= X0000203;
		result.a = 1.0;
	}
}

//
// The following method is the root function of the shader graph
//
float4 mi_metallic_paint_flakes_1_eval(State state)
{
	float4 result;
	mi_metallic_paint_flakes_main(ambient, base_color, edge_color, edge_color_bias, lit_color, lit_color_bias, diffuse_weight, diffuse_bias, irradiance_weight, spec, spec_weight, spec_exp, spec_sec, spec_sec_weight, spec_sec_exp, spec_glazing, flake_color, flake_weight, flake_reflect, flake_exp, flake_decay, flake_bump, global_weight, mode, flake_density, flake_strength, flake_scale, noise_random_texture, noise_corr_texture, (state), result);
	return result;
}

//
// This function is the main method of the fragment shader. It initializes the
// values in the state structure that are used by nodes in the shader graph
// and produces the final result of the shader.
//
float4 fragment_main(
	Vert2frag fs_in) : COLOR
{
	State state;
	state.position = fs_in.position;
	state.normal = sign(fs_in.fcolor.r - 0.5) * normalize(fs_in.normal);
	state.geom_normal = state.normal;
	state.ray_length = length(state.position);
	state.direction = state.position/state.ray_length;
	state.dot_nd = dot(state.direction, state.normal);
	if (state.dot_nd > 0f) {
		state.dot_nd = -state.dot_nd;
		state.normal = -state.normal;
		state.geom_normal = -state.geom_normal;
	}
	return mi_metallic_paint_flakes_1_eval(state);
}

//
// The following define the default technique and pass of the effect.
//
technique T0
{
	pass P0
	{
		DepthTestEnable = true;
		DepthMask       = true;
		CullFaceEnable  = false;
		VertexShader = compile vp40 vertex_main();
		PixelShader  = compile fp40 fragment_main();
	}
}
//
// The following define the default technique and pass of the effect.
//
technique T1
{
	pass P0
	{
		DepthTestEnable = true;
		DepthMask       = true;
		CullFaceEnable  = false;
		VertexShader = compile glslv vertex_main();
		PixelShader  = compile glslf fragment_main();
	}
}

// So far, Directional Light has been ported to be supported by			       
// both Mental mill and Catia.								       
// 											       
// To do: Implement the other light types as well for Catia				       
											       
#ifndef __WORLD_TO_CAMERA								       
#define __WORLD_TO_CAMERA								       
float4x4 __world_to_camera : View;							       
#endif											       
											       
											       
struct SLightDir : Light								       
{											       
											       
    //											       
    // The following are free parameters of the shader that should be set by the	       
    // application at runtime.								       
    //											       
											       
    const float3 LightPos;								       
    const float3 LightDir;								       
    const float3 LightColor;								       
    const float3 LightColorSpec;							       
    const float3 lightI_SCos_SExp;							       
											       
    void Light_directional_main(float3 color, State state, out float4 result)								       
    {											       
	    result = float4(LightColor.xyz, 1.0) * 3.141592;				       
    }											       
    Light_iterator eval(State state)							       
    {											       
	    state.light_to_surface = mul((float3x3)__world_to_camera, -LightDir); // catmod	       
	    state.light_distance = length(state.light_to_surface);				       
	    state.light_to_surface /= state.light_distance;					       
	    state.light_dotnl = dot(-state.light_to_surface, state.normal);			       

	    float4 result;									       
	    Light_directional_main(LightColor, (state), result);	
	    //result	= float4(LightColor, 1.0);					       
	    			       
	    Light_iterator __light_out;							       
	    __light_out.raw_contribution = result;						       
	    __light_out.contribution = __light_out.raw_contribution;			       
	    __light_out._point     = LightPos;						       
	    __light_out.distance  = state.light_distance;					       
	    __light_out.dot_nl    = state.light_dotnl;					       
	    __light_out.direction = -state.light_to_surface;				       
	    return __light_out;								       
    }											       
											       
};											       
											       
											       
// ---------------- implementation of point light --------------			       
struct SLightPoint : Light								       
{											       
    const float3 LightPos;							       
    const float3 LightDir;								       
    const float3 LightColor;
    const float3 LightColorSpec;							       
    const float3 lightI_SCos_SExp;							       
											       
    // the catia function evaluation							       
    Light_iterator eval(State state)							       
    {											       
	    // BRING LIGHTS TO CAMERASPACE!!!!						       
	    float3 lightpos_camspace = mul(__world_to_camera, float4((LightPos).xyz, 1.0)).xyz;    
	    state.light_to_surface   = state.position - lightpos_camspace;			       
	    state.light_distance     =  length(state.light_to_surface);			       
	    state.light_to_surface   = normalize(state.light_to_surface);			       
	    state.light_dotnl        = dot(-state.light_to_surface, state.normal);		       
    											       
	    float4 result;									       
	    result	= float4(LightColor, 1.0) * 3.141592; //rbx				       
	    //result	= float4(LightColor, 1.0);					       
	    // would do light-shader evaluation here...					       
    											       
	    Light_iterator __light_out;							       
	    __light_out.raw_contribution   = result;					       
	    __light_out.contribution       = __light_out.raw_contribution;			       
	    __light_out._point             = lightpos_camspace;				       
	    __light_out.distance           = state.light_distance;				       
	    __light_out.dot_nl             = state.light_dotnl;				       
	    __light_out.direction          = -state.light_to_surface;			       
	    return __light_out;								       
    }											       
};											       
											       

// ---------------- implementation of spot light --------------			       
struct SLightSpot : Light								       
{											       
    const float3 LightPos;						       
    const float3 LightDir;								       
    const float3 LightColor;
    const float3 LightColorSpec;							       
    const float3 lightI_SCos_SExp;							       
											       
    // the catia function evaluation							       
    Light_iterator eval(State state)							       
    {											       
	    // BRING LIGHTS TO CAMERASPACE!!!!						       
	    float3 lightpos_camspace = mul(__world_to_camera, float4((LightPos).xyz, 1.0)).xyz;    
	    state.light_to_surface   = state.position - lightpos_camspace;			       
	    state.light_distance     =  length(state.light_to_surface);			       
	    state.light_to_surface   = normalize(state.light_to_surface);			       
	    state.light_dotnl        = dot(-state.light_to_surface, state.normal);		       
    											       
	    float4 result;									       
	    result	= float4(LightColor, 1.0) * 3.141592; //rbx				       
	    //result	= float4(LightColor, 1.0);					       
	    // would do light-shader evaluation here...					       

	    // cone 
	    float3 lightdir_camspace = mul((float3x3)__world_to_camera, LightDir);	       
	    float d = dot(state.light_to_surface, lightdir_camspace);
      if (d < 0)
      {
        result.rgb = 0;
      }
      if (d < lightI_SCos_SExp.y)
      {
        result.rgb = 0;
      }
    										       
	    Light_iterator __light_out;							       
	    __light_out.raw_contribution   = result;					       
	    __light_out.contribution       = __light_out.raw_contribution;			       
	    __light_out._point             = lightpos_camspace;				       
	    __light_out.distance           = state.light_distance;				       
	    __light_out.dot_nl             = state.light_dotnl;				       
	    __light_out.direction          = -state.light_to_surface;			       
	    return __light_out;								       
    }											       
};											       
