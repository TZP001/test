/**
 * © Dassault Systèmes 2008 – Do not reproduce, copy or use without a license from Dassault Systèmes
 * CGFX Shader for CATIA V5
 * Author: Jerome Derel
 * Date: 21.05.2008
 */


/******************************************************************/
/* DATA - STRUCTURES */
/******************************************************************/

struct LIGHT_INFOS
{
	float3 position;
	float3 direction;
	float4 ambient;
	float4 diffuse;
	float4 specular;
};

struct MATERIAL_INFOS
{
	float3 position;
	float3 normal;
	float3 tangent;
	float3 binormal;
};

struct CAMERA_INFOS
{
	float3 position;
	float3 direction;
};


struct LIGHT_RESULT
{
	float4 contribution;
};

struct ILLUMINATION_RESULT
{
	float4 ambient;
	float4 diffuse;
	float4 specular;
};


/******************************************************************/
/* LIGHT - PARAMETERS */
/******************************************************************/

#ifdef IN_FXCOMPOSER2
/* Simple lighting implementation in FXC2 */
float3 _LightPos : Position
<
	string Object = "PointLight0";
	string Space = "World";
	string UIName = "Light0 Light_position";
> = float3(0.0f,0.0f,0.0f);

float4 _LightAmbient
<
	string UIName = "Light0 Ambient Color";
	string UIWidget = "Color";
> = float4(0.2f,0.2f,0.2f,1.0f);

float4 _LightDiffuse
<
	string UIName = "Light0 Diffuse Color";
	string UIWidget = "Color";
> = float4(0.5f,0.5f,0.5f,1.0f);

float4 _LightSpecular
<
	string UIName = "Light0 Specular Color";
	string UIWidget = "Color";
> = float4(0.8f,0.8f,0.8f,1.0f);
#endif


/******************************************************************/
/* LIGHT - STRUCTURES */
/******************************************************************/

interface Light
{
	float3 getPosition(MATERIAL_INFOS material_infos);
	float3 getDirection(MATERIAL_INFOS material_infos);
	float4 getAmbient();
	float4 getDiffuse();
	float4 getSpecular();
	LIGHT_RESULT compute(MATERIAL_INFOS material_infos);
};

struct SLightDir : Light
{
	const float3 LightPos;
	const float3 LightDir;
	const float3 LightUp;
	const float3 LightRight;
	
	const float4 LightAmbient;
	const float4 LightDiffuse;
	const float4 LightSpecular;
	
	const float LightAxialFalloffStart;
	const float LightAxialFalloffEnd;
	const float LightAxialFalloffConstant;
	const float LightAxialFalloffLinear;
	const float LightAxialFalloffQuadratic;
	
	const float LightRadialInnerCone; /* cosf(InnerConeAngle * 3.14159f / 180.0f) */
	const float LightRadialOuterCone; /* cosf(OuterConeAngle * 3.14159f / 180.0f) */
	const float LightRadialFalloffExponent;
	
	const float LightAreaType;
	const float LightAreaStatus;
	const float2 LightAreaGeometry;
	
	
	float3 getPosition(MATERIAL_INFOS material_infos)
	{
		return LightPos;
	}
	
	float3 getDirection(MATERIAL_INFOS material_infos)
	{
		return LightDir;
	}
	
	float4 getAmbient()
	{
		return LightAmbient;
	}
	
	float4 getDiffuse()
	{
		return LightDiffuse;
	}
	
	float4 getSpecular()
	{
		return LightSpecular;
	}
	
	LIGHT_RESULT compute(MATERIAL_INFOS material_infos)
	{
		LIGHT_RESULT light_result = (LIGHT_RESULT)0;
		
		light_result.contribution = float4(1.0f,1.0f,1.0f,1.0f);
		
		
		return light_result;
	}
};

struct SLightPoint : Light
{
	const float3 LightPos;
	const float3 LightDir;
	const float3 LightUp;
	const float3 LightRight;
	
	const float4 LightAmbient;
	const float4 LightDiffuse;
	const float4 LightSpecular;
	
	const float LightAxialFalloffStart;
	const float LightAxialFalloffEnd;
	const float LightAxialFalloffConstant;
	const float LightAxialFalloffLinear;
	const float LightAxialFalloffQuadratic;
	
	const float LightRadialInnerCone; /* cosf(InnerConeAngle * 3.14159f / 180.0f) */
	const float LightRadialOuterCone; /* cosf(OuterConeAngle * 3.14159f / 180.0f) */
	const float LightRadialFalloffExponent;
	
	const float LightAreaType;
	const float LightAreaStatus;
	const float2 LightAreaGeometry;
	
	
	float3 getPosition(MATERIAL_INFOS material_infos)
	{
		#ifdef IN_FXCOMPOSER2
		return _LightPos;
		#else
		return LightPos;
		#endif
	}
	
	float3 getDirection(MATERIAL_INFOS material_infos)
	{
		return getPosition(material_infos) - material_infos.position;
	}
	
	float4 getAmbient()
	{
		#ifdef IN_FXCOMPOSER2
		return _LightAmbient;
		#else
		return LightAmbient;
		#endif
	}
	
	float4 getDiffuse()
	{
		#ifdef IN_FXCOMPOSER2
		return _LightDiffuse;
		#else
		return LightDiffuse;
		#endif
	}
	
	float4 getSpecular()
	{
		#ifdef IN_FXCOMPOSER2
		return _LightSpecular;
		#else
		return LightSpecular;
		#endif
	}
	
	LIGHT_RESULT compute(MATERIAL_INFOS material_infos)
	{
		LIGHT_RESULT light_result = (LIGHT_RESULT)0;
		
		light_result.contribution = float4(1.0f,1.0f,1.0f,1.0f);
		
		
		/* Axial Falloff */
		if(LightAxialFalloffConstant <1.0f)
		{
			float distance = length(getDirection(material_infos));
			
			float d = max(distance-LightAxialFalloffStart,0.0f);
			d /= max(LightAxialFalloffEnd - distance,0.001f);
			float axialFalloff = 1.0f/(1.0f + LightAxialFalloffLinear*d + LightAxialFalloffQuadratic*d*d);
			
			light_result.contribution *= axialFalloff;
		}
		
		
		return light_result;
	}
};

struct SLightSpot : Light
{
	const float3 LightPos;
	const float3 LightDir;
	const float3 LightUp;
	const float3 LightRight;
	
	const float4 LightAmbient;
	const float4 LightDiffuse;
	const float4 LightSpecular;
	
	const float LightAxialFalloffStart;
	const float LightAxialFalloffEnd;
	const float LightAxialFalloffConstant;
	const float LightAxialFalloffLinear;
	const float LightAxialFalloffQuadratic;
	
	const float LightRadialInnerCone; /* cosf(InnerConeAngle * 3.14159f / 180.0f) */
	const float LightRadialOuterCone; /* cosf(OuterConeAngle * 3.14159f / 180.0f) */
	const float LightRadialFalloffExponent;
	
	const float LightAreaType;
	const float LightAreaStatus;
	const float2 LightAreaGeometry;
	
	
	float3 getPosition(MATERIAL_INFOS material_infos)
	{
		return LightPos;
	}
	
	float3 getDirection(MATERIAL_INFOS material_infos)
	{
		return getPosition(material_infos) - material_infos.position;
	}
	
	float4 getAmbient()
	{
		return LightAmbient;
	}
	
	float4 getDiffuse()
	{
		return LightDiffuse;
	}
	
	float4 getSpecular()
	{
		return LightSpecular;
	}
	
	LIGHT_RESULT compute(MATERIAL_INFOS material_infos)
	{
		LIGHT_RESULT light_result = (LIGHT_RESULT)0;
		
		light_result.contribution = float4(1.0f,1.0f,1.0f,1.0f);
		
		
		/* Radial Falloff */
		float3 normal = material_infos.normal;
		float3 direction = normalize(getDirection(material_infos));
		
		float lightAngle = dot(direction,normalize(-LightDir));
		lightAngle = clamp(lightAngle,0.0f,1.0f);
		
		float t = lightAngle + (1.0f-LightRadialInnerCone) - LightRadialOuterCone;
		t = clamp(t/(1.0f-LightRadialOuterCone),0.0f,1.0f);
		
		float radialFalloff = clamp((3.0f*t*t*(1.0f-t) + t*t*t),0.0f,1.0f);
		radialFalloff = pow(radialFalloff,LightRadialFalloffExponent);
		
		light_result.contribution *= radialFalloff;
		
		
		/* Axial Falloff */
		if(LightAxialFalloffConstant <1.0f)
		{
			float distance = length(getDirection(material_infos));
			
			float d = max(distance-LightAxialFalloffStart,0.0f);
			d /= max(LightAxialFalloffEnd - distance,0.001f);
			float axialFalloff = 1.0f/(1.0f + LightAxialFalloffLinear*d + LightAxialFalloffQuadratic*d*d);
			
			light_result.contribution *= axialFalloff;
		}
		
		
		return light_result;
	}
};


/******************************************************************/
/* MATERIAL - "UN-TWEAKABLE" PARAMETERS */
/******************************************************************/

/* Lights interface
 * 
 * Functions :
 * float3 getPosition(MATERIAL_INFOS)
 * float3 getDirection(MATERIAL_INFOS)
 * float4 getAmbient()
 * float4 getDiffuse()
 * float4 getSpecular()
 * LIGHT_RESULT compute(MATERIAL_INFOS)
 * 
 */
#ifdef IN_FXCOMPOSER2
SLightPoint lights[1];
#else
Light lights[];
#endif


/* Matrix transformations */
float4x4 World : World;
float4x4 WorldIT : WorldIT;
float4x4 View : View;
float4x4 ViewIT : ViewIT;
float4x4 Wvp : WorldViewProjection;

/* Uncomment the line below if tangent and binormal of the surface are needed */
//int NeedTandB = 1;

/* Global Ambient */
float4 GlobalAmbientColor : GLOBALAMBIENTCOLOR;

/******************************************************************/
/* MATERIAL - TWEAKABLE PARAMETERS */
/******************************************************************/

/* Ambient parameters */
float AmbientStrength
<
	float UIMin = 0.0f;
	float UIMax = 20.0f;
> = 0.5f;

float4 AmbientColor : Ambient
<
	string Desc = "Ambient color";
> = {0.0f,0.27f,0.35f,1.0f};


/* Diffuse parameters */
float DiffuseStrength
<
	float UIMin = 0.0f;
	float UIMax = 20.0f;
> = 0.5f;

float4 DiffuseColor : Diffuse
<
	string Desc = "Diffuse color";
> = {0.0f,0.35f,0.32f,1.0f};


/* Specular parameters */
float SpecularStrength
<
	float UIMin = 0.0f;
	float UIMax = 20.0f;
> = 0.5f;

float4 SpecularColor : Specular
<
	string Desc = "Specular color";
> = {0.73f,0.73f,0.73f,1.0f};

float SpecularPower
<
	float UIMin = 0.0f;
	float UIMax = 250.0f;
> = 100.0f;


/******************************************************************/
/* MATERIAL - TEXTURES */
/******************************************************************/




/******************************************************************/
/* MATERIAL - ILLUMINATION FUNCTION */
/******************************************************************/

/* Toon Phong illumination model */
ILLUMINATION_RESULT compute(LIGHT_INFOS light_infos,MATERIAL_INFOS material_infos,
	CAMERA_INFOS camera_infos,LIGHT_RESULT light_result)
{
	ILLUMINATION_RESULT result = (ILLUMINATION_RESULT)0;
	
	/* Lobe shape */
	float3 Hn = normalize(camera_infos.direction + light_infos.direction);
	float4 shape = lit(dot(light_infos.direction,material_infos.normal),
		dot(Hn,material_infos.normal),SpecularPower);
	
	if(shape.y<0.5f)
	{
		shape.y=0.0f;
	}
	else
	{
		shape.y=1.0f;
	}
	
	if (shape.z<0.2f)
	{
		shape.z=0.0f;
	}
	else
	{
		shape.z=1.0f;
	}
	
	
	
	/* Add lobe contribution */
	result.ambient = light_result.contribution*light_infos.ambient;
	result.diffuse = light_result.contribution*light_infos.diffuse*shape.y;
	result.specular = light_result.contribution*light_infos.specular*shape.z*result.diffuse;
	
	return result;
}


/******************************************************************/
/* MATERIAL - FUNCTIONS */
/******************************************************************/




/******************************************************************/
/* MATERIAL - VERTEX & FRAGMENT STRUCTURES */
/******************************************************************/

struct Application2Vertex
{
	float3 position : POSITION;
	float4 uv : TEXCOORD0;
	float4 normal : NORMAL;
	float4 tangent : TEXCOORD1;
	float4 binormal	: TEXCOORD2;
};

struct Vertex2Fragment
{
	float4 screenPosition : POSITION;
	float2 uv : TEXCOORD0;
	float3 worldPosition : TEXCOORD1;
	float3 worldNormal : TEXCOORD2;
	float3 worldTangent : TEXCOORD3;
	float3 worldBinormal : TEXCOORD4;
	float3 worldEye : TEXCOORD5;
};


/******************************************************************/
/* MATERIAL - VERTEX & FRAGMENT PROGRAMS */
/******************************************************************/

/* Basic Vertex Program */
Vertex2Fragment BasicVP(Application2Vertex IN)
{
	Vertex2Fragment OUT = (Vertex2Fragment)0;
	
	float4 position = float4(IN.position.xyz,1.0f);
	OUT.screenPosition = mul(Wvp,position); 
	
	OUT.uv = IN.uv.xy;
	
	float3 worldPosition = mul(World,position).xyz;
	OUT.worldPosition= worldPosition;
	
	OUT.worldNormal = normalize(mul(WorldIT,IN.normal)).xyz;
	OUT.worldTangent = normalize(mul(WorldIT,IN.tangent)).xyz;
	OUT.worldBinormal = normalize(mul(WorldIT,IN.binormal)).xyz;
	
	OUT.worldEye = ViewIT[3].xyz;
	
	return OUT;
}

/* Toon Fragment Program */
float4 ToonFP(Vertex2Fragment IN,float vf : FACE) : COLOR
{
	/* Vertex input */
	float3 position = IN.worldPosition;
	float2 uv = IN.uv;
	float3 normal = normalize(IN.worldNormal);
	float3 tangent = normalize(IN.worldTangent);
	float3 binormal = normalize(IN.worldBinormal);
	float3 eye = IN.worldEye;
	
	/* Camera information */
	CAMERA_INFOS camera_infos = (CAMERA_INFOS)0;
	camera_infos.position = eye;
	camera_infos.direction = normalize(eye-position);
	
	/* Normal orientation */
	if(vf < 0.0f) normal = -normal;

	
	/* Material information */
	MATERIAL_INFOS material_infos = (MATERIAL_INFOS)0;
	material_infos.position = position;
	material_infos.normal = normal;
	material_infos.tangent = tangent;
	material_infos.binormal = binormal;
	
	
	/* Lighting result */
	LIGHT_INFOS light_infos = (LIGHT_INFOS)0;
	LIGHT_RESULT light_result = (LIGHT_RESULT)0;
	ILLUMINATION_RESULT illumination_result = (ILLUMINATION_RESULT)0;
	illumination_result.ambient += GlobalAmbientColor;
	
	for(int i=0; i<lights.length; i++)
	{
		/* Light information */
		light_infos.position = lights[i].getPosition(material_infos);
		light_infos.direction = normalize(lights[i].getDirection(material_infos));
		light_infos.ambient = lights[i].getAmbient();
		light_infos.diffuse = lights[i].getDiffuse();
		light_infos.specular = lights[i].getSpecular();
		
		/* Light computation */
		light_result = lights[i].compute(material_infos);
		
		/* Illumination computation */
		ILLUMINATION_RESULT ir = compute(light_infos,material_infos,camera_infos,light_result);
		illumination_result.ambient += ir.ambient;
		illumination_result.diffuse += ir.diffuse;
		illumination_result.specular += ir.specular;
	}
	
	
	/* Material result */
	float4 result = (float4)0;
	
	if(dot(camera_infos.direction,normal)>0.1f)
	{
		/* Basic contribution */
		result += illumination_result.ambient*(AmbientStrength*AmbientColor);
		result += illumination_result.diffuse*(DiffuseStrength*DiffuseColor);
		result += illumination_result.specular*(SpecularStrength*SpecularColor);
	}
	
	return float4(result.xyz,1.0f);
}


/******************************************************************/
/* MATERIAL - TECHNIQUES */
/******************************************************************/

technique Toon
{
	pass p0
	{
		/* Uncomment the line below to show stickers correctly */
		PolygonOffset = float2(2.0,2.0);
		
		DepthTestEnable=true;
		DepthMask = true;
		DepthFunc = LEqual;
		
		/* Uncomment the line(s) below to enable transparency */
		//BlendEnable = true;
		#ifdef IN_FXCOMPOSER2
		//BlendFunc = int2(SrcAlpha, One);
		#endif
		
		
		VertexProgram = compile vp40 BasicVP();
		
		FragmentProgram = compile fp40 ToonFP();
	}
}
technique ToonGLSL
{
	pass p0
	{
		/* Uncomment the line below to show stickers correctly */
		PolygonOffset = float2(2.0,2.0);
		
		DepthTestEnable=true;
		DepthMask = true;
		DepthFunc = LEqual;
		
		/* Uncomment the line(s) below to enable transparency */
		//BlendEnable = true;
		#ifdef IN_FXCOMPOSER2
		//BlendFunc = int2(SrcAlpha, One);
		#endif
		
		
		VertexProgram = compile glslv BasicVP();
		
		FragmentProgram = compile glslf ToonFP();
	}
}

