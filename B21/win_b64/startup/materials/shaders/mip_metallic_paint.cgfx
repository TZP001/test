/******************************************************************************
 * The following code was generated by the mental mill(tm)                    *
 *                                                                            *
 * Copyright 1986-2007 by mental images GmbH, Fasanenstr. 81, D-10623         *
 * Berlin, Germany. All rights reserved.                                      *
******************************************************************************/

//
// The state structure is used internally within the fragment shader to
// commonly used values.
//
struct State
{
	float4 tex_coord[4];
	float3 tangent[1];
	float3 binormal[1];
	float3 tex_du[1];
	float3 tex_dv[1];
	float3 position;
	float3 normal;
	float3 geom_normal;
	float3 motion;
	float2 raster;
	bool backside;
	float3 direction;
	float ray_length;
	float dot_nd;
	float3x3 tangent_space[1];
	float importance;
	float4 volume_input;
	float3 light_position;
	float3 light_direction;
	float3 light_to_surface;
	float light_distance;
	float light_dotnl;
	int light_type;
	float light_spread;
	float light_spread_cos;
	float light_distance_limit;
};

//
// Values for the light_type parameter of light shaders
//
#define LIGHT_POINT    0
#define LIGHT_SPOT     1
#define LIGHT_INFINITE 2
#define LIGHT_PLANAR   3

//
// The light iterator structure holds the return values resulting from
// evaluating a light.
//
struct Light_iterator {
	float3 _point;
	float4 contribution;
	float4 raw_contribution;
	float  dot_nl;
	float3 direction;
	float  distance;
	float4 shadow;
	int    count;
};

struct Ray {
	float3 origin;
	float3 direction;
};

//
// The light interface defines a method used to evaluate different types
// of lights. Light shaders are generated as structs which implement this
// interface.
//
interface Light {
	Light_iterator eval(State state);
};

void __make_basis(const float3 n, const float3 u, const float3 v,
        out float3 t, out float3 b)
{
    b = normalize(cross(u,n));
    t = cross(n,b);
    if (dot(b,v) < 0.0)  b = -b;
}

float3 __perspective_divide(float4 pt)
{
    return pt.xyz/pt.w;
}

//
// The following are free parameters of the shader that should be set by the
// application at runtime.
//
float4 ambient
<
	string UIName = "Ambient color";
	string UIWidget = "Color";
> = float4(0.000000, 0.000000, 0.000000, 1.000000);
float4 base_color
<
	string UIName = "Base color ";
	string UIWidget = "Color";
> = float4(0.800000, 0.100000, 0.000000, 1.000000);
float4 edge_color
<
	string UIName = "Edge tone color ";
	string UIWidget = "Color";
> = float4(0.600000, 0.070000, 0.070000, 1.000000);
float edge_color_bias
<
	string UIName = "Edge tone bias ";
	string UIWidget = "slider";
	float UIMin = 0;
	float UIMax = 1;
	float UIStep = 0.01;
> = 1.000000;
float4 lit_color
<
	string UIName = "Light tone color";
	string UIWidget = "Color";
> = float4(0.600000, 0.000000, 0.200000, 1.000000);
float lit_color_bias
<
	string UIName = "Light tone bias";
	string UIWidget = "slider";
	float UIMin = 0;
	float UIMax = 1;
	float UIStep = 0.01;
> = 8.000000;
float diffuse_weight
<
	string UIName = "Diffuse weight ";
	string UIWidget = "slider";
	float UIMin = 0;
	float UIMax = 1;
	float UIStep = 0.01;
> = 1.000000;
float diffuse_bias
<
	string UIName = "Diffuse bias ";
	string UIWidget = "slider";
	float UIMin = 0;
	float UIMax = 1;
	float UIStep = 0.01;
> = 1.500000;
float irradiance_weight
<
	string UIName = "Irradiance weight ";
	string UIWidget = "slider";
	float UIMin = 0;
	float UIMax = 1;
	float UIStep = 0.01;
> = 1.000000;
float4 spec
<
	string UIName = "Specular_1 color ";
	string UIWidget = "Color";
> = float4(1.000000, 1.000000, 1.000000, 1.000000);
float spec_weight
<
	string UIName = "Specular_1 weight ";
	string UIWidget = "slider";
	float UIMin = 0;
	float UIMax = 1;
	float UIStep = 0.01;
> = 0.200000;
float spec_exp
<
	string UIName = "Specular_1 Exponent ";
	float UIMin = 30.000000;
	float UIMax = 250.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 60.000000;
float4 spec_sec
<
	string UIName = "Specular_2 Color ";
	string UIWidget = "Color";
> = float4(1.000000, 1.000000, 1.000000, 1.000000);
float spec_sec_weight
<
	string UIName = "Specular_2 weight ";
	string UIWidget = "slider";
	float UIMin = 0;
	float UIMax = 1;
	float UIStep = 0.01;
> = 0.507614;
float spec_sec_exp
<
	string UIName = "Specular2 exponent ";
	float UIMin = 10.000000;
	float UIMax = 50.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 25.000000;
bool spec_glazing
<
	string UIName = "Specular glazing ";
> = true;
float4 flake_color
<
	string UIName = "Flake Color";
	string UIWidget = "Color";
> = float4(1.000000, 1.000000, 1.000000, 1.000000);
float flake_weight
<
	string UIName = "Flake weight";
	string UIWidget = "slider";
	float UIMin = 0;
	float UIMax = 1;
	float UIStep = 0.01;
> = 1.000000;
float flake_reflect
<
	string UIName = "Flake Reflect";
	string UIWidget = "slider";
	float UIMin = 0;
	float UIMax = 1;
	float UIStep = 0.01;
> = 0.000000;
float flake_exp
<
	string UIName = "Flake exponent";
	string UIWidget = "slider";
	float UIMin = 0;
	float UIMax = 1;
	float UIStep = 0.01;
> = 45.000000;
float flake_decay
<
	string UIName = "Flake decay";
	string UIWidget = "slider";
	float UIMin = 0;
	float UIMax = 1;
	float UIStep = 0.01;
> = 0.000000;
int flake_bump = 0;
float global_weight
<
	string UIName = "Global weight";
	string UIWidget = "slider";
	float UIMin = 0;
	float UIMax = 1;
	float UIStep = 0.01;
> = 1.000000;
int mode = 0;


//
// The following are parameters representing non-varying state variables 
// referenced by the shader. These should be set by the application at runtime.
// Note that vector parameters should be provided in camera space.
//
#ifndef __OBJECT_TO_NDC
#define __OBJECT_TO_NDC
float4x4 __object_to_ndc : WorldViewProjection
<
	string UIWidget = "none";
>;
#endif
#ifndef __OBJECT_TO_CAMERA
#define __OBJECT_TO_CAMERA
float4x4 __object_to_camera : WorldView
<
	string UIWidget = "none";
>;
#endif
#ifndef __CAMERA_TO_OBJECT
#define __CAMERA_TO_OBJECT
float4x4 __camera_to_object : WorldViewI
<
	string UIWidget = "none";
>;
#endif
#ifndef SCENE_AMBIENT
#define SCENE_AMBIENT
float4 __scene_ambient = float4(0.00,0.00,0.00,0.00);
#endif

//
// The following array represents the attachment points to lights.
// The application should use the Cg runtime to create instances of
// light of shaders and attach them before final compilation with
// the Cg compiler.
//
Light lights[];

//
// The App2vert structure defines the vertex attributes used by the vertex
// shader. The application should supply a vertex stream containing these 
// elements.
//
struct App2vert
{
	float3 position : POSITION;
	float3 normal : NORMAL;
};

//
// The Vert2frag structure defines values used by the fragment shader and
// supplied by the vertex shader.
//
struct Vert2frag
{
	float4 hpos : POSITION;
	float3 position : TEXCOORD0;
	float3 normal : TEXCOORD1;
	float4 fcolor : COLOR0;
	float4 bcolor : BCOL0;
};

//
// This function is the main method of the vertex shader.
//
Vert2frag vertex_main(
	App2vert vs_in)
{
	Vert2frag vs_out;
	float4 position = float4(vs_in.position, 1);
	vs_out.hpos = mul(__object_to_ndc, position);
	vs_out.position = mul(__object_to_camera, position).xyz;
	vs_out.normal = mul(vs_in.normal, (float3x3)__camera_to_object);
	vs_out.fcolor = float4(1,0,0,0);
	vs_out.bcolor = float4(0,0,0,0);
	return vs_out;
}

//
// The following functions are generated from the MetaSL implementation of
// the shaders that are part of the compiled shader graph.
//

float X0000000_mi_metallic_paint_o(
	float3 X0000002,
	float3 X0000003,
	float3 X0000004,
	float X0000005)
{
	float X0000006 = 0.0;
	float3 X0000007 = X0000002 - X0000003;
	float X0000008 = dot(X0000007, X0000004);
	X0000008 *= (X0000008 / (dot(X0000007, X0000007)));
	if (X0000008 > 0.0)
	{
		X0000006 = (exp((((log(X0000008)) * 0.5) * X0000005)));
	}
	return X0000006;
}

float X0000001_mi_metallic_paint_o(
	float X0000009,
	float X0000010,
	float X0000011)
{
	float X0000012;
	float X0000013;
	if (X0000011 <= X0000009)
	{
		X0000013 = 0.0;
	}
	else
	{
		if (X0000011 >= X0000010)
		{
			X0000013 = 1.0;
		}
		else
		{
			X0000012 = ((X0000011 - X0000009) / (X0000010 - X0000009));
			X0000013 = ((X0000012 * X0000012) * (3.0 - (2.0 * X0000012)));
		}
	}
	return X0000013;
}

void mi_metallic_paint_o_main(
	float4 ambient,
	float4 base_color,
	float4 edge_color,
	float edge_color_bias,
	float4 lit_color,
	float lit_color_bias,
	float diffuse_weight,
	float diffuse_bias,
	float irradiance_weight,
	float4 spec,
	float spec_weight,
	float spec_exp,
	float4 spec_sec,
	float spec_sec_weight,
	float spec_sec_exp,
	bool spec_glazing,
	float4 flake_color,
	float flake_weight,
	float flake_reflect,
	float flake_exp,
	float flake_decay,
	int flake_bump,
	float global_weight,
	int mode,
	State state,
	out float4 result)
{
	{
		float X0000014 = 3.1415926535897932384626433832795;
		float X0000015 = irradiance_weight / X0000014;
		bool X0000016;
		if (flake_weight > 0.0)
		{
			X0000016 = true;
		}
		else
		{
			X0000016 = false;
		}
		float4 X0000017;
		float3 X0000018;
		float3 X0000019;
		float3 X0000020;
		float X0000021;
		float X0000022;
		float X0000023;
		if (global_weight <= 0.0)
		{
			global_weight = 1.0;
		}
		if (spec_exp <= 0.0)
		{
			spec_weight = 0.0;
		}
		if (spec_sec_exp <= 0)
		{
			spec_sec_weight = 0.0f;
		}
		if (diffuse_bias < 0)
		{
			diffuse_bias = 0.0f;
		}
		X0000019 = (mul((__camera_to_object), (float4((state.position), 1.0)))).xyz;
		X0000020 = (mul((__camera_to_object), (float4((state.position), 1.0)))).xyz;
		X0000020 -= X0000019;
		X0000021 = (((X0000020.x * X0000020.x) + (X0000020.y * X0000020.y)) + (X0000020.z * X0000020.z));
		X0000020 = (normalize(X0000020));
		if (edge_color_bias > 0.0)
		{
			X0000022 = (abs((dot((state.normal), (state.direction)))));
			X0000022 = (pow(X0000022, edge_color_bias));
			X0000023 = (1.0 - X0000022);
			X0000017 = ((base_color * X0000022) + (edge_color * X0000023));
		}
		result = (ambient * X0000017);
		Light_iterator X0000024;
		float4 X0000025 = float4(0.0, 0.0, 0.0, 1.0);
		float3 X0000026;
		float X0000027;
		float4 X0000028;
		float X0000029;
		for (int light_index=0;
		     light_index < lights.length;
		     light_index++)
		{
			X0000024 = lights[light_index].eval(state); X0000024.count = light_index;
			float4 X0000030 = X0000024.contribution / 3.14159265358979323846f;
			X0000025 = (float4(0.0, 0.0, 0.0, 1.0));
			if (X0000024.dot_nl < 0.0)
			{
				X0000027 = 0;
			}
			else
			{
				X0000027 = X0000024.dot_nl;
			}
			X0000029 = ((pow(X0000027, diffuse_bias)) * diffuse_weight);
			if (lit_color_bias > 0.0)
			{
				X0000022 = (pow(X0000027, lit_color_bias));
				X0000022 *= (abs((dot((state.normal), (state.direction)))));
				X0000023 = (1.0 - X0000022);
				X0000028 = ((X0000017 * X0000023) + (lit_color * X0000022));
			}
			else
			{
				X0000028 = X0000017;
			}
			X0000025 += ((X0000029 * X0000028) * X0000030);
			X0000022 = (pow(X0000027, 0.5f));
			X0000026 = X0000024.direction;
			if (spec_weight > 0.0)
			{
				X0000029 = (X0000000_mi_metallic_paint_o(X0000024.direction, (state.direction), (state.normal), spec_exp));
				if (X0000029 > 0.0)
				{
					if (spec_glazing)
					{
						X0000029 = (X0000001_mi_metallic_paint_o(0.5, 0.8, X0000029));
					}
					X0000029 *= (spec_weight * X0000022);
					X0000025 += ((X0000029 * spec) * X0000030);
				}
			}
			if (spec_sec_weight > 0.0)
			{
				X0000029 = (((X0000000_mi_metallic_paint_o(X0000024.direction, (state.direction), (state.normal), spec_sec_exp)) * spec_sec_weight) * X0000022);
				if (X0000029 > 0.0)
				{
					X0000025 += ((X0000029 * spec_sec) * X0000030);
				}
			}
			result += X0000025;
		}
		if (X0000015 > 0.0)
		{
			
			result += ((X0000015 * (__scene_ambient)) * X0000017);
		}
		result *= global_weight;
		result.a = 1.0;
	}
}

//
// The following method is the root function of the shader graph
//
float4 mi_metallic_paint_o_1_eval(State state)
{
	float4 result;
	mi_metallic_paint_o_main(ambient, base_color, edge_color, edge_color_bias, lit_color, lit_color_bias, diffuse_weight, diffuse_bias, irradiance_weight, spec, spec_weight, spec_exp, spec_sec, spec_sec_weight, spec_sec_exp, spec_glazing, flake_color, flake_weight, flake_reflect, flake_exp, flake_decay, flake_bump, global_weight, mode, (state), result);
	return result;
}

//
// This function is the main method of the fragment shader. It initializes the
// values in the state structure that are used by nodes in the shader graph
// and produces the final result of the shader.
//
float4 fragment_main(
	Vert2frag fs_in) : COLOR
{
	State state;
	state.position = fs_in.position;
	state.normal = sign(fs_in.fcolor.r - 0.5) * normalize(fs_in.normal);
	state.ray_length = length(state.position);
	state.direction = state.position/state.ray_length;
	state.dot_nd = dot(state.direction, state.normal);
	if (state.dot_nd > 0f) {
		state.dot_nd = -state.dot_nd;
		state.normal = -state.normal;
	}
	return mi_metallic_paint_o_1_eval(state);
}

//
// The following define the default technique and pass of the effect.
//
technique T0
{
	pass P0
	{
		DepthTestEnable = true;
		DepthMask       = true;
		CullFaceEnable  = false;
		VertexShader = compile vp40 vertex_main();
		PixelShader  = compile fp40 fragment_main();
	}
}
//
// The following define the default technique and pass of the effect.
//
technique T1
{
	pass P0
	{
		DepthTestEnable = true;
		DepthMask       = true;
		CullFaceEnable  = false;
		VertexShader = compile glslv vertex_main();
		PixelShader  = compile glslf fragment_main();
	}
}

// So far, Directional Light has been ported to be supported by			       
// both Mental mill and Catia.								       
// 											       
// To do: Implement the other light types as well for Catia				       
											       
#ifndef __WORLD_TO_CAMERA								       
#define __WORLD_TO_CAMERA								       
float4x4 __world_to_camera : View;							       
#endif											       
											       
											       
struct SLightDir : Light								       
{											       
											       
    //											       
    // The following are free parameters of the shader that should be set by the	       
    // application at runtime.								       
    //											       
											       
    const float3 LightPos;								       
    const float3 LightDir;								       
    const float3 LightColor;								       
    const float3 LightColorSpec;							       
    const float3 lightI_SCos_SExp;							       
											       
    void Light_directional_main(float3 color, State state, out float4 result)								       
    {											       
	    result = float4(LightColor.xyz, 1.0) * 3.141592;				       
    }											       
    Light_iterator eval(State state)							       
    {											       
	    state.light_to_surface = mul((float3x3)__world_to_camera, -LightDir); // catmod	       
	    state.light_distance = length(state.light_to_surface);				       
	    state.light_to_surface /= state.light_distance;					       
	    state.light_dotnl = dot(-state.light_to_surface, state.normal);			       

	    float4 result;									       
	    Light_directional_main(LightColor, (state), result);	
	    //result	= float4(LightColor, 1.0);					       
	    			       
	    Light_iterator __light_out;							       
	    __light_out.raw_contribution = result;						       
	    __light_out.contribution = __light_out.raw_contribution;			       
	    __light_out._point     = LightPos;						       
	    __light_out.distance  = state.light_distance;					       
	    __light_out.dot_nl    = state.light_dotnl;					       
	    __light_out.direction = -state.light_to_surface;				       
	    return __light_out;								       
    }											       
											       
};											       
											       
											       
// ---------------- implementation of point light --------------			       
struct SLightPoint : Light								       
{											       
    const float3 LightPos;							       
    const float3 LightDir;								       
    const float3 LightColor;
    const float3 LightColorSpec;							       
    const float3 lightI_SCos_SExp;							       
											       
    // the catia function evaluation							       
    Light_iterator eval(State state)							       
    {											       
	    // BRING LIGHTS TO CAMERASPACE!!!!						       
	    float3 lightpos_camspace = mul(__world_to_camera, float4((LightPos).xyz, 1.0)).xyz;    
	    state.light_to_surface   = state.position - lightpos_camspace;			       
	    state.light_distance     =  length(state.light_to_surface);			       
	    state.light_to_surface   = normalize(state.light_to_surface);			       
	    state.light_dotnl        = dot(-state.light_to_surface, state.normal);		       
    											       
	    float4 result;									       
	    result	= float4(LightColor, 1.0) * 3.141592; //rbx				       
	    //result	= float4(LightColor, 1.0);					       
	    // would do light-shader evaluation here...					       
    											       
	    Light_iterator __light_out;							       
	    __light_out.raw_contribution   = result;					       
	    __light_out.contribution       = __light_out.raw_contribution;			       
	    __light_out._point             = lightpos_camspace;				       
	    __light_out.distance           = state.light_distance;				       
	    __light_out.dot_nl             = state.light_dotnl;				       
	    __light_out.direction          = -state.light_to_surface;			       
	    return __light_out;								       
    }											       
};											       
											       

// ---------------- implementation of spot light --------------			       
struct SLightSpot : Light								       
{											       
    const float3 LightPos;						       
    const float3 LightDir;								       
    const float3 LightColor;
    const float3 LightColorSpec;							       
    const float3 lightI_SCos_SExp;							       
											       
    // the catia function evaluation							       
    Light_iterator eval(State state)							       
    {											       
	    // BRING LIGHTS TO CAMERASPACE!!!!						       
	    float3 lightpos_camspace = mul(__world_to_camera, float4((LightPos).xyz, 1.0)).xyz;    
	    state.light_to_surface   = state.position - lightpos_camspace;			       
	    state.light_distance     =  length(state.light_to_surface);			       
	    state.light_to_surface   = normalize(state.light_to_surface);			       
	    state.light_dotnl        = dot(-state.light_to_surface, state.normal);		       
    											       
	    float4 result;									       
	    result	= float4(LightColor, 1.0) * 3.141592; //rbx				       
	    //result	= float4(LightColor, 1.0);					       
	    // would do light-shader evaluation here...					       

	    // cone 
	    float3 lightdir_camspace = mul((float3x3)__world_to_camera, LightDir);	       
	    float d = dot(state.light_to_surface, lightdir_camspace);
      if (d < 0)
      {
        result.rgb = 0;
      }
      if (d < lightI_SCos_SExp.y)
      {
        result.rgb = 0;
      }
    										       
	    Light_iterator __light_out;							       
	    __light_out.raw_contribution   = result;					       
	    __light_out.contribution       = __light_out.raw_contribution;			       
	    __light_out._point             = lightpos_camspace;				       
	    __light_out.distance           = state.light_distance;				       
	    __light_out.dot_nl             = state.light_dotnl;				       
	    __light_out.direction          = -state.light_to_surface;			       
	    return __light_out;								       
    }											       
};											       
