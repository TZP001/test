/******************************************************************************
 * The following code was generated by the mental mill(R)                     *
 *                                                                            *
 * Copyright 1986-2007 by mental images GmbH, Fasanenstr. 81, D-10623         *
 * Berlin, Germany. All rights reserved.                                      *
******************************************************************************/

//
// The state structure is used internally within the fragment shader to
// commonly used values.
//
struct State
{
	float4 tex_coord[4];
	float3 tangent[1];
	float3 binormal[1];
	float3 tex_du[1];
	float3 tex_dv[1];
	float3 position;
	float3 normal;
	float3 geom_normal;
	float3 motion;
	float2 raster;
	bool backside;
	float3 direction;
	float ray_length;
	float dot_nd;
	float3x3 tangent_space[1];
	float importance;
	float4 volume_input;
	float3 light_position;
	float3 light_direction;
	float3 light_to_surface;
	float light_distance;
	float light_dotnl;
	int light_type;
	float light_spread;
	float light_spread_cos;
	float light_distance_limit;
};

//
// Values for the light_type parameter of light shaders
//
#define LIGHT_POINT    0
#define LIGHT_SPOT     1
#define LIGHT_INFINITE 2
#define LIGHT_PLANAR   3

//
// The light iterator structure holds the return values resulting from
// evaluating a light.
//
struct Light_iterator {
	float3 _point;
	float4 contribution;
	float4 raw_contribution;
	float  dot_nl;
	float3 direction;
	float  distance;
	float4 shadow;
	int    count;
};

struct Ray {
	float3 origin;
	float3 direction;
};

//
// The light interface defines a method used to evaluate different types
// of lights. Light shaders are generated as structs which implement this
// interface.
//
interface Light {
	Light_iterator eval(State state);
};

void __make_basis(const float3 n, const float3 u, const float3 v,
        out float3 t, out float3 b)
{
    b = normalize(cross(u,n));
    t = cross(n,b);
    if (dot(b,v) < 0.0)  b = -b;
}

float3 __perspective_divide(float4 pt)
{
    return pt.xyz/pt.w;
}

//
// The following are free parameters of the shader that should be set by the
// application at runtime.
//
texture __Environment_map_cubic_1_env_tex <
	string UIName = "Environment_map_cubic_1_env_tex";
	string ResourceName = "CATRmaCpt_Environment_CUBEMap_Hall_1024.dds";
	string ResourceType = "Cube";
>;

samplerCUBE Environment_map_cubic_1_env_tex
<
	string File = "CATRmaCpt_Environment_CUBEMap_Hall_1024.dds";
> = sampler_state {
	Texture = <__Environment_map_cubic_1_env_tex>;
	MinFilter = LinearMipMapLinear;
	MagFilter = Linear;
	WrapR = ClampToEdge;
	WrapS = ClampToEdge;
	WrapT = ClampToEdge;
};

float Environment_map_cubic_1_intensity
<
	string UIName = "Intensity";
	float UIMin = 0.000000;
	float UIMax = 10.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 1.000000;
float diffuse_weight
<
	string UIName = "Diffuse level";
	float UIMin = 0.000000;
	float UIMax = 1.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 1.000000;
float4 diffuse
<
	string UIName = "Color";
	float4 UIMin = float4(0.000000, 0.000000, 0.000000, 0.000000);
	float4 UIMax = float4(1.000000, 1.000000, 1.000000, 1.000000);
	float UIStep = 0.01;
	string UIWidget = "slider";
> = float4(0.500000, 0.500000, 0.500000, 1.000000);
float diffuse_roughness
<
	string UIName = "Roughness";
	float UIMin = 0.000000;
	float UIMax = 1.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.000000;
float reflectivity
<
	string UIName = "Reflectivity";
	float UIMin = 0.000000;
	float UIMax = 1.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.800000;
float4 refl_color
<
	string UIName = "Reflection color";
	float4 UIMin = float4(0.000000, 0.000000, 0.000000, 0.000000);
	float4 UIMax = float4(1.000000, 1.000000, 1.000000, 1.000000);
	float UIStep = 0.01;
	string UIWidget = "slider";
> = float4(1.000000, 1.000000, 1.000000, 1.000000);
float refl_gloss
<
	string UIName = "Reflection glossiness";
	float UIMin = 0.000000;
	float UIMax = 1.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.500000;
bool refl_hl_only
<
	string UIName = "Reflect highlights and FG only";
> = false;
bool refl_is_metal
<
	string UIName = "Metal material";
> = true;
float transparency
<
	string UIName = "Transparency";
	float UIMin = 0.000000;
	float UIMax = 1.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.000000;
float4 refr_color
<
	string UIName = "Refraction color";
	float4 UIMin = float4(0.000000, 0.000000, 0.000000, 0.000000);
	float4 UIMax = float4(1.000000, 1.000000, 1.000000, 1.000000);
	float UIStep = 0.01;
	string UIWidget = "slider";
> = float4(1.000000, 1.000000, 1.000000, 1.000000);
float refr_gloss
<
	string UIName = "Refraction glossiness";
	float UIMin = 0.000000;
	float UIMax = 1.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 1.000000;
float refr_ior
<
	string UIName = "Index of refraction";
	float UIMin = 0.010000;
	float UIMax = 4.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 1.400000;
bool refr_translucency
<
	string UIName = "Refraction translucency";
> = false;
float4 refr_trans_color
<
	string UIName = "Refraction translucent color";
	float4 UIMin = float4(0.000000, 0.000000, 0.000000, 0.000000);
	float4 UIMax = float4(1.000000, 1.000000, 1.000000, 1.000000);
	float UIStep = 0.01;
	string UIWidget = "slider";
> = float4(0.000000, 0.000000, 0.000000, 1.000000);
float refr_trans_weight
<
	string UIName = "Refraction translucent weight";
	float UIMin = 0.000000;
	float UIMax = 1.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.500000;
float anisotropy
<
	string UIName = "Anisotropy";
	float UIMin = 0.000000;
	float UIMax = 2.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 1.000000;
float anisotropy_rotation
<
	string UIName = "Anisotropy rotation";
	float UIMin = 0.000000;
	float UIMax = 1.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.000000;
bool brdf_fresnel
<
	string UIName = "BRDF fresnel";
> = true;
float brdf_0_degree_refl
<
	string UIName = "BRDF 0 degree reflection";
	float UIMin = 0.000000;
	float UIMax = 1.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.200000;
float brdf_90_degree_refl
<
	string UIName = "BRDF 90 degree reflection";
	float UIMin = 0.000000;
	float UIMax = 1.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 1.000000;
float brdf_curve
<
	string UIName = "BRDF Curve shape ";
	float UIMin = 0.000000;
	float UIMax = 10.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 5.000000;
bool brdf_conserve_energy
<
	string UIName = "BRDF conserve energy";
> = true;
bool ao_on
<
	string UIName = "Ambient occlusion active";
> = false;
float ao_distance
<
	string UIName = "Ambient occlusion max distance";
	float UIMin = 0.000000;
	float UIMax = 200.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 10.000000;
float4 ao_dark
<
	string UIName = "ambient occlusion dark color";
	float4 UIMin = float4(0.000000, 0.000000, 0.000000, 0.000000);
	float4 UIMax = float4(1.000000, 1.000000, 1.000000, 1.000000);
	float UIStep = 0.01;
	string UIWidget = "slider";
> = float4(0.200000, 0.200000, 0.200000, 1.000000);
float4 ao_ambient
<
	string UIName = "Ambient occlusion ambient color";
	float4 UIMin = float4(0.000000, 0.000000, 0.000000, 0.000000);
	float4 UIMax = float4(1.000000, 1.000000, 1.000000, 1.000000);
	float UIStep = 0.01;
	string UIWidget = "slider";
> = float4(0.000000, 0.000000, 0.000000, 1.000000);
bool ao_do_details
<
	string UIName = "Ambient occlusion details";
> = true;
bool thin_walled
<
	string UIName = "Thin walled mode";
> = false;
bool skip_inside_refl
<
	string UIName = "Skip reflection on inside";
> = true;
bool backface_cull
<
	string UIName = "Backface culling active";
> = false;
float hl_vs_refl_balance
<
	string UIName = "Highlight vs. reflection balance";
	float UIMin = 0.000000;
	float UIMax = 1.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 1.000000;
float cutout_opacity
<
	string UIName = "Cutout opacity";
	float UIMin = 0.000000;
	float UIMax = 1.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 1.000000;
bool no_diffuse_bump = false;


//
// The following are parameters representing non-varying state variables 
// referenced by the shader. These should be set by the application at runtime.
// Note that vector parameters should be provided in camera space.
//
#ifndef __OBJECT_TO_NDC
#define __OBJECT_TO_NDC
float4x4 __object_to_ndc : WorldViewProjection
<
	string UIWidget = "none";
>;
#endif
#ifndef __REFRACTED_IOR
#define __REFRACTED_IOR
float __refracted_ior = 1.01;
#endif
#ifndef __INCIDENT_IOR
#define __INCIDENT_IOR
float __incident_ior = 1.0;
#endif
#ifndef __OBJECT_TO_CAMERA
#define __OBJECT_TO_CAMERA
float4x4 __object_to_camera : WorldView
<
	string UIWidget = "none";
>;
#endif
#ifndef __CAMERA_TO_WORLD
#define __CAMERA_TO_WORLD
float4x4 __camera_to_world : ViewI
<
	string UIWidget = "none";
>;
#endif
#ifndef __CAMERA_TO_OBJECT
#define __CAMERA_TO_OBJECT
float4x4 __camera_to_object : WorldViewI
<
	string UIWidget = "none";
>;
#endif
#ifndef SCENE_AMBIENT
#define SCENE_AMBIENT
float4 __scene_ambient = float4(0.00,0.00,0.00,0.00);
#endif

//
// The following array represents the attachment points to lights.
// The application should use the Cg runtime to create instances of
// light of shaders and attach them before final compilation with
// the Cg compiler.
//
Light lights[];

//
// The App2vert structure defines the vertex attributes used by the vertex
// shader. The application should supply a vertex stream containing these 
// elements.
//
struct App2vert
{
	float3 position : POSITION;
	float3 normal : NORMAL;
};

//
// The Vert2frag structure defines values used by the fragment shader and
// supplied by the vertex shader.
//
struct Vert2frag
{
	float4 hpos : POSITION;
	float3 position : TEXCOORD0;
	float3 normal : TEXCOORD1;
	float4 fcolor : COLOR0;
	float4 bcolor : BCOL0;
};

//
// This function is the main method of the vertex shader.
//
Vert2frag vertex_main(
	App2vert vs_in)
{
	Vert2frag vs_out;
	float4 position = float4(vs_in.position, 1);
	vs_out.hpos = mul(__object_to_ndc, position);
	vs_out.position = mul(__object_to_camera, position).xyz;
	vs_out.normal = mul(vs_in.normal, (float3x3)__camera_to_object);
	vs_out.fcolor = float4(1,0,0,0);
	vs_out.bcolor = float4(0,0,0,0);
	return vs_out;
}

//
// The following functions are generated from the MetaSL implementation of
// the shaders that are part of the compiled shader graph.
//

void Environment_map_cubic_main(
	samplerCUBE env_tex,
	float intensity,
	State state,
	out float4 __local_result)
{
	{
		float3 v = mul(((float3x3 )(__camera_to_world)), (state.direction));
		__local_result = (texCUBE(env_tex, v.xyz));
		__local_result *= intensity;
	}
}

void Environment_map_cubic_1_main(
	State state,
	out float4 result)
{
	{
		Environment_map_cubic_main(Environment_map_cubic_1_env_tex, Environment_map_cubic_1_intensity, (state), result);
	}
}

float4 __reflect_environment(
	State state)
{
	(state.direction) = (reflect((state.position), (state.normal)));
	float4 result;
	Environment_map_cubic_1_main((state), result);
	return result;
}

float4 __refract_environment(
	State state)
{
	(state.direction) = (refract((state.position), (state.normal), ((__refracted_ior) / (__incident_ior))));
	float4 result;
	Environment_map_cubic_1_main((state), result);
	return result;
}

float4 __trace_environment(
	State state,
	Ray ray)
{
	(state.position) = ray.origin;
	(state.direction) = ray.direction;
	float4 result;
	Environment_map_cubic_1_main((state), result);
	return result;
}

void X0000000_mia_material(
	out float3 X0000027,
	out float3 X0000028,
	in int X0000029,
	in float3 X0000030)
{
	float3 X0000031 = float3(0.0, 0.0, 1.0);
	float X0000032;
	X0000031 = (mul((float3x3)__object_to_camera, X0000031));
	X0000031 = (normalize(X0000031));
	X0000032 = (dot(X0000030, X0000031));
	if ((abs(X0000032)) > 0.999)
	{
		X0000031 = (float3(0.0, 1.0, 0.0));
		X0000031 = (mul((float3x3)__object_to_camera, X0000031));
		X0000031 = (normalize(X0000031));
		X0000032 = (dot(X0000030, X0000031));
		if ((abs(X0000032)) > 0.999)
		{
			X0000031 = (float3(1.0, 0.0, 0.0));
			X0000031 = (mul((float3x3)__object_to_camera, X0000031));
			X0000031 = (normalize(X0000031));
			X0000032 = (dot(X0000030, X0000031));
		}
	}
	X0000031 -= (X0000030 * X0000032);
	X0000031 = (normalize(X0000031));
	X0000028 = X0000031;
	X0000027 = (cross(X0000028, X0000030));
}

void X0000001_mia_material(
	out float3 X0000033,
	out float3 X0000034,
	out float X0000035,
	out float3 X0000036,
	out float3 X0000037,
	in float3 X0000038,
	in float3 X0000039,
	in float anisotropy_rotation,
	in int anisotropy_channel)
{
	{
		int X0000040 = anisotropy_channel;
		X0000033 = X0000039;
		X0000034 = X0000039;
		X0000035 = (dot(X0000038, X0000039));
		X0000000_mia_material(X0000036, X0000037, X0000040, X0000039);
		float X0000041;
		X0000041 = (dot(X0000039, X0000036));
		X0000036 -= (X0000039 * X0000041);
		X0000036 = (normalize(X0000036));
		X0000041 = (dot(X0000039, X0000037));
		X0000037 -= (X0000039 * X0000041);
		X0000037 = (normalize(X0000037));
		if (anisotropy_rotation != 0.0)
		{
			float X0000042 = (anisotropy_rotation * 3.14159265358979323846f) * 2.0;
			float X0000043 = cos(X0000042);
			float X0000044 = sin(X0000042);
			float3 X0000045 = (X0000043 * X0000036) + (X0000044 * X0000037);
			X0000037 = (((-X0000044) * X0000036) + (X0000043 * X0000037));
			X0000036 = X0000045;
		}
	}
}

float X0000002_mia_material(
	in float X0000046,
	in float X0000047,
	in float X0000048,
	in float X0000049)
{
	float X0000050;
	float X0000051;
	float X0000052;
	float X0000053;
	if (X0000046 == X0000047)
	{
		return 0.0;
	}
	else
	{
		X0000050 = ((X0000046 * X0000049) + (X0000047 * X0000048));
		if (X0000050 == 0.0)
		{
			X0000052 = 1.0;
		}
		else
		{
			X0000052 = (((X0000046 * X0000049) - (X0000047 * X0000048)) / X0000050);
		}
		X0000051 = ((X0000046 * X0000048) + (X0000047 * X0000049));
		if (X0000051 == 0.0)
		{
			X0000053 = 1.0;
		}
		else
		{
			X0000053 = (((X0000046 * X0000048) - (X0000047 * X0000049)) / X0000051);
		}
		return 0.5 * ((X0000052 * X0000052) + (X0000053 * X0000053));
	}
}

float X0000003_mia_material(
	in float X0000054,
	in float X0000055,
	in float X0000056)
{
	float X0000057;
	float X0000058;
	X0000057 = (X0000055 / X0000056);
	X0000058 = (1.0 - ((X0000057 * X0000057) * (1.0 - (X0000054 * X0000054))));
	if (X0000058 > 0.0)
	{
		return X0000002_mia_material(X0000055, X0000056, X0000054, (-(sqrt(X0000058))));
	}
	else
	{
		return 1.0;
	}
}

void X0000004_mia_material(
	out bool X0000059,
	out bool X0000060,
	out float X0000061,
	out float4 X0000062,
	out float4 X0000063,
	out float4 X0000064,
	out float X0000065,
	out bool X0000066,
	out bool X0000067,
	out float X0000068,
	out float4 X0000069,
	out bool X0000070,
	out bool X0000071,
	out float X0000072,
	out int X0000073,
	out float X0000074,
	out float X0000075,
	out float X0000076,
	out int X0000077,
	out float X0000078,
	out float X0000079,
	out int X0000080,
	out float X0000081,
	out bool X0000082,
	out float X0000083,
	out bool X0000084,
	out float4 X0000085,
	out bool X0000086,
	out bool X0000087,
	out float X0000088,
	in float3 X0000089,
	in float3 X0000090,
	in float X0000091,
	in bool X0000092,
	in float diffuse_weight,
	in float4 diffuse,
	in float reflectivity,
	in float4 refl_color,
	in float refl_gloss,
	in int refl_gloss_samples,
	in bool refl_interpolate,
	in bool refl_hl_only,
	in bool refl_is_metal,
	in float transparency,
	in float4 refr_color,
	in float refr_gloss,
	in float refr_ior,
	in int refr_gloss_samples,
	in bool refr_interpolate,
	in bool refr_translucency,
	in float4 refr_trans_color,
	in float refr_trans_weight,
	in float anisotropy,
	in bool brdf_fresnel,
	in float brdf_0_degree_refl,
	in float brdf_90_degree_refl,
	in float brdf_curve,
	in bool brdf_conserve_energy,
	in bool intr_refl_ddist_on,
	in float intr_refl_ddist,
	in bool single_env_sample,
	in float refl_cutoff,
	in bool refr_falloff_on,
	in float refr_falloff_dist,
	in bool refr_falloff_color_on,
	in float4 refr_falloff_color,
	in float refr_cutoff,
	in float fg_quality,
	in float fg_quality_w,
	in bool ao_on,
	in int ao_samples,
	in float ao_distance,
	in bool ao_do_details,
	in bool thin_walled,
	in bool skip_inside_refl,
	in float hl_vs_refl_balance,
	in bool no_diffuse_bump)
{
	{
		X0000085 = (float4(0.0, 0.0, 0.0, 0.0));
		float4 X0000093 = float4(0.212671, 0.715160, 0.072169, 0.0);
		X0000059 = no_diffuse_bump;
		X0000060 = refl_hl_only;
		X0000061 = anisotropy;
		float X0000094 = diffuse_weight;
		float X0000095 = reflectivity;
		float X0000096 = transparency;
		X0000062 = diffuse;
		X0000063 = refl_color;
		X0000064 = refr_color;
		X0000065 = refr_ior;
		X0000066 = thin_walled;
		X0000067 = single_env_sample;
		if (brdf_fresnel)
		{
			if (X0000092 && (!X0000066))
			{
				X0000095 *= (X0000003_mia_material(X0000091, X0000065, 1.0));
			}
			else
			{
				X0000095 *= (X0000003_mia_material(X0000091, 1.0, X0000065));
			}
		}
		else
		{
			float X0000097 = brdf_0_degree_refl;
			float X0000098 = brdf_90_degree_refl;
			float X0000099 = brdf_curve;
			float X0000100 = pow((1.0 - (abs((dot(X0000089, X0000090))))), X0000099);
			X0000095 *= ((X0000098 * X0000100) + (X0000097 * (1.0 - X0000100)));
		}
		if ((X0000092 && (!X0000066)) && skip_inside_refl)
		{
			X0000068 = (smoothstep(0.5, 0.9, X0000095));
		}
		else
		{
			X0000068 = 1.0;
		}
		if (refl_is_metal)
		{
			X0000094 *= (1.0 - ((((X0000063.r * X0000093.r) + (X0000063.g * X0000093.g)) + (X0000063.b * X0000093.b)) * X0000095));
			if (X0000094 < 0.0)
			{
				X0000094 = 0.0;
			}
			X0000063.r *= X0000062.r;
			X0000063.g *= X0000062.g;
			X0000063.b *= X0000062.b;
		}
		X0000062.a = (((X0000062.r * X0000093.r) + (X0000062.g * X0000093.g)) + (X0000062.b * X0000093.b));
		X0000063.a = (((X0000063.r * X0000093.r) + (X0000063.g * X0000093.g)) + (X0000063.b * X0000093.b));
		X0000064.a = (((X0000064.r * X0000093.r) + (X0000064.g * X0000093.g)) + (X0000064.b * X0000093.b));
		X0000063 *= X0000095;
		if (brdf_conserve_energy)
		{
			float X0000101 = X0000064.a * X0000096;
			if (X0000101 > 1.0)
			{
				X0000101 = 1.0;
			}
			X0000094 *= (1.0 - X0000101);
		}
		if (brdf_conserve_energy)
		{
			float X0000102 = X0000063.a;
			if (X0000102 > 1.0)
			{
				X0000102 = 1.0;
			}
			X0000096 *= (1.0 - X0000102);
			X0000094 *= (1.0 - X0000102);
		}
		if ((X0000092 || X0000066) && refr_translucency)
		{
			float X0000103 = refr_trans_weight;
			X0000069 = refr_trans_color;
			X0000069.r *= ((X0000064.r * X0000096) * X0000103);
			X0000069.g *= ((X0000064.g * X0000096) * X0000103);
			X0000069.b *= ((X0000064.b * X0000096) * X0000103);
			X0000069.a = (((X0000069.r * X0000093.r) + (X0000069.g * X0000093.g)) + (X0000069.b * X0000093.b));
			X0000096 *= (1.0 - X0000103);
		}
		else
		{
			X0000069 = (float4(0.0, 0.0, 0.0, 0.0));
		}
		X0000064 *= X0000096;
		if (X0000060)
		{
			X0000094 += X0000063.a;
		}
		X0000062 *= X0000094;
		X0000070 = ao_on;
		if (X0000070)
		{
			X0000071 = ao_do_details;
			X0000072 = ao_distance;
			X0000073 = ao_samples;
		}
		X0000074 = 0.0;
		if (X0000063.a > 0.0)
		{
			X0000075 = hl_vs_refl_balance;
			X0000076 = refl_gloss;
			X0000077 = refl_gloss_samples;
			X0000078 = refl_cutoff;
			if (intr_refl_ddist_on)
			{
				X0000074 = intr_refl_ddist;
			}
		}
		if (X0000064.a > 0.0)
		{
			X0000079 = refr_gloss;
			X0000080 = refr_gloss_samples;
			X0000081 = refr_cutoff;
			X0000082 = refr_falloff_on;
			if (X0000082)
			{
				X0000083 = refr_falloff_dist;
				X0000084 = refr_falloff_color_on;
				if (X0000084)
				{
					X0000085 = refr_falloff_color;
					if (X0000085.r < 0.0)
					{
						X0000085.r = 0.0;
					}
					if (X0000085.g < 0.0)
					{
						X0000085.g = 0.0;
					}
					if (X0000085.b < 0.0)
					{
						X0000085.b = 0.0;
					}
					X0000085.a = (((X0000085.r * X0000093.r) + (X0000085.g * X0000093.g)) + (X0000085.b * X0000093.b));
				}
			}
			else
			{
				X0000083 = 0.0;
			}
		}
		else
		{
			X0000082 = false;
			X0000084 = false;
		}
		X0000086 = refl_interpolate;
		X0000087 = refr_interpolate;
		float X0000104 = fg_quality_w;
		X0000088 = fg_quality;
		if (X0000104 > 0.0)
		{
			X0000088 *= X0000104;
			if (X0000088 < 1.0)
			{
				X0000088 = 1.0;
			}
		}
	}
}

float4 X0000005_mia_material(
	in Light_iterator X0000105,
	in float4 X0000106,
	in float3 X0000107,
	in float3 X0000108,
	in float diffuse_roughness)
{
	{
		float X0000109 = 0.0;
		if (X0000105.dot_nl < 0.9999)
		{
			X0000109 = (acos(X0000105.dot_nl));
		}
		if (X0000109 < ((-3.14159265358979323846f) * 0.49))
		{
			X0000109 = ((-3.14159265358979323846f) * 0.49);
		}
		if (X0000109 > (3.14159265358979323846f * 0.49))
		{
			X0000109 = (3.14159265358979323846f * 0.49);
		}
		float3 X0000110 = X0000107;
		float X0000111 = dot(X0000108, X0000110);
		if (X0000111 < 0.0)
		{
			X0000111 = (-X0000111);
			X0000110.x = (-X0000110.x);
			X0000110.y = (-X0000110.y);
			X0000110.z = (-X0000110.z);
		}
		float X0000112 = 0.0;
		if (X0000111 < 0.9999)
		{
			X0000112 = (acos(X0000111));
		}
		if (X0000109 < X0000112)
		{
			float X0000113 = X0000112;
			X0000112 = X0000109;
			X0000109 = X0000113;
		}
		float3 X0000114;
		float3 X0000115;
		X0000114.x = (X0000110.x - (X0000108.x * X0000111));
		X0000114.y = (X0000110.y - (X0000108.y * X0000111));
		X0000114.z = (X0000110.z - (X0000108.z * X0000111));
		X0000115.x = (X0000105.direction.x - (X0000108.x * X0000105.dot_nl));
		X0000115.y = (X0000105.direction.y - (X0000108.y * X0000105.dot_nl));
		X0000115.z = (X0000105.direction.z - (X0000108.z * X0000105.dot_nl));
		float X0000116 = (length(X0000114)) * (length(X0000115));
		float X0000117;
		if ((abs(X0000116)) < 0.0001)
		{
			X0000117 = 1.0;
		}
		else
		{
			X0000117 = ((dot(X0000114, X0000115)) / X0000116);
		}
		if (X0000117 < (-1.0))
		{
			X0000117 = (-1.0);
		}
		if (X0000117 > 1.0)
		{
			X0000117 = 1.0;
		}
		float X0000118;
		float X0000119;
		if (X0000117 >= 0.0)
		{
			X0000119 = ((2.0 * (-X0000112)) * (1.0 / 3.14159265358979323846f));
		}
		else
		{
			X0000119 = ((2.0 * X0000112) * (1.0 / 3.14159265358979323846f));
		}
		X0000118 = ((X0000119 * X0000119) * X0000119);
		float X0000120 = diffuse_roughness * diffuse_roughness;
		float X0000121 = X0000120 / (X0000120 + 0.09);
		float X0000122 = 1.0 - (0.5 * (X0000120 / (X0000120 + 0.33)));
		float X0000123 = (0.45 * X0000121) * ((sin(X0000109)) - X0000118);
		X0000119 = (((4.0 * X0000109) * X0000112) * (1.0 / (3.14159265358979323846f * 3.14159265358979323846f)));
		float X0000124 = ((0.125 * X0000121) * X0000119) * X0000119;
		float X0000125 = tan(X0000112);
		float X0000126 = tan(((X0000109 + X0000112) * 0.5));
		if (X0000125 < (-100.0))
		{
			X0000125 = (-100.0);
		}
		if (X0000125 > 100.0)
		{
			X0000125 = 100.0;
		}
		if (X0000126 < (-100.0))
		{
			X0000126 = (-100.0);
		}
		if (X0000126 > 100.0)
		{
			X0000126 = 100.0;
		}
		float X0000127 = (X0000122 + ((X0000123 * X0000117) * X0000125)) + ((X0000124 * (1.0 - (abs(X0000117)))) * X0000126);
		X0000119 = ((2.0 * X0000112) * (1.0 / 3.14159265358979323846f));
		float X0000128 = (0.17 * (X0000120 / (X0000120 + 0.13))) * (1.0 - ((X0000117 * X0000119) * X0000119));
		float X0000129;
		float4 X0000130 = float4(0.0, 0.0, 0.0, 0.0);
		X0000129 = ((X0000127 * X0000106.r) + ((X0000128 * X0000106.r) * X0000106.r));
		if (X0000129 > 1.0)
		{
			X0000130.r = 1.0;
		}
		else
		{
			X0000130.r = X0000129;
		}
		X0000129 = ((X0000127 * X0000106.g) + ((X0000128 * X0000106.g) * X0000106.g));
		if (X0000129 > 1.0)
		{
			X0000130.g = 1.0;
		}
		else
		{
			X0000130.g = X0000129;
		}
		X0000129 = ((X0000127 * X0000106.b) + ((X0000128 * X0000106.b) * X0000106.b));
		if (X0000129 > 1.0)
		{
			X0000130.b = 1.0;
		}
		else
		{
			X0000130.b = X0000129;
		}
		return X0000130;
	}
}

float X0000006_mia_material(
	in float X0000131)
{
	return pow(2.0, (X0000131 * 8.0));
}

float X0000007_mia_material(
	in float3 X0000132,
	in float3 X0000133,
	in float3 X0000134,
	in float3 X0000135,
	in float3 X0000136,
	in float X0000137,
	in float X0000138)
{
	float X0000139 = 0.0001;
	float X0000140 = dot(X0000133, X0000134);
	float X0000141 = -(dot(X0000132, X0000134));
	if ((X0000141 * X0000140) < X0000139)
	{
		return 0.0;
	}
	else
	{
		float X0000142 = X0000137 * X0000137;
		float X0000143 = X0000138 * X0000138;
		float3 X0000144 = X0000133 - X0000132;
		X0000144 = (normalize(X0000144));
		float X0000145 = dot(X0000144, X0000134);
		X0000145 *= X0000145;
		if (X0000145 > 1.0)
		{
			X0000145 = 1.0;
		}
		float X0000146 = dot(X0000144, X0000135);
		X0000146 *= X0000146;
		float X0000147 = dot(X0000144, X0000136);
		X0000147 *= X0000147;
		if (X0000145 < (X0000139 * ((X0000146 * X0000142) + (X0000147 * X0000143))))
		{
			return 0.0;
		}
		else
		{
			float X0000148 = (-((X0000146 * X0000142) + (X0000147 * X0000143))) / X0000145;
			return (((exp(X0000148)) * X0000137) * X0000138) / (((sqrt((X0000141 * X0000140))) * 4.0) * 3.14159265358979323846f);
		}
	}
}

void X0000008_mia_material(
	inout float X0000149,
	inout float X0000150,
	in float X0000151,
	in float X0000152)
{
	float X0000153 = (2 * X0000151) - 1;
	float X0000154 = (2 * X0000152) - 1;
	if ((X0000153 == 0.0) && (X0000154 == 0.0))
	{
		X0000150 = 0.0;
		X0000149 = 0.0;
	}
	else
	{
		if (X0000153 > (-X0000154))
		{
			if (X0000153 > X0000154)
			{
				X0000149 = X0000153;
				X0000150 = ((3.14159265358979323846f / 4.0) * (1.0 + (X0000154 / X0000153)));
			}
			else
			{
				X0000149 = X0000154;
				X0000150 = ((3.14159265358979323846f / 4.0) * (3.0 - (X0000153 / X0000154)));
			}
		}
		else
		{
			if (X0000153 < X0000154)
			{
				X0000149 = (-X0000153);
				X0000150 = ((3.14159265358979323846f / 4.0) * (5.0 + (X0000154 / X0000153)));
			}
			else
			{
				X0000149 = (-X0000154);
				X0000150 = ((3.14159265358979323846f / 4.0) * (7.0 - (X0000153 / X0000154)));
			}
		}
	}
}

void X0000009_mia_material(
	inout float3 X0000155,
	in float3 X0000156,
	in float X0000157,
	in float X0000158,
	in float X0000159)
{
	float3 X0000160;
	float3 X0000161;
	float3 X0000162 = mul(X0000156, (float3x3)__object_to_camera);
	if ((abs(X0000162.x)) < (abs(X0000162.y)))
	{
		X0000160.x = 0.0;
		X0000160.y = (-X0000162.z);
		X0000160.z = X0000162.y;
	}
	else
	{
		X0000160.x = X0000162.z;
		X0000160.y = 0.0;
		X0000160.z = (-X0000162.x);
	}
	X0000160 = (mul((float3x3)__object_to_camera, X0000160));
	if ((length(X0000160)) == 0.0)
	{
		if ((abs(X0000156.x)) < (abs(X0000156.y)))
		{
			X0000160.x = 0.0;
			X0000160.y = (-X0000156.z);
			X0000160.z = X0000156.y;
		}
		else
		{
			X0000160.x = X0000156.z;
			X0000160.y = 0.0;
			X0000160.z = (-X0000156.x);
		}
	}
	X0000160 = (normalize(X0000160));
	X0000161 = (cross(X0000156, X0000160));
	X0000155 = (((X0000157 * X0000160) + (X0000158 * X0000161)) + (X0000159 * X0000156));
}

void X0000010_mia_material(
	inout float3 X0000163,
	in float3 X0000164,
	in float2 X0000165)
{
	float X0000166 = 0.0001;
	float X0000167 = 0.0;
	float X0000168 = 0.0;
	X0000008_mia_material(X0000167, X0000168, X0000165.x, X0000165.y);
	float X0000169 = X0000167 * (cos(X0000168));
	float X0000170 = X0000167 * (sin(X0000168));
	float X0000171 = (1.0 - (X0000169 * X0000169)) - (X0000170 * X0000170);
	float X0000172;
	if (X0000171 > 0.0)
	{
		X0000172 = (sqrt(X0000171));
	}
	else
	{
		X0000172 = 0.0;
	}
	X0000009_mia_material(X0000163, X0000164, X0000169, X0000170, X0000172);
}

void X0000011_mia_material(
	inout float3 X0000173,
	in float3 X0000174,
	in float3 X0000175,
	in float X0000176,
	in float2 X0000177)
{
	float X0000178 = 1000000000000000000000000000000000000.0;
	float X0000179;
	float3 X0000180 = reflect(X0000174, X0000175);
	if (X0000176 > 0)
	{
		X0000179 = (1.0 / X0000176);
	}
	else
	{
		X0000179 = X0000178;
	}
	float X0000181 = (2.0 * 3.14159265358979323846f) * X0000177.x;
	float X0000182 = atan((X0000179 * (sqrt((-(log((1.0 - X0000177.y))))))));
	float X0000183 = (cos(X0000181)) * (sin(X0000182));
	float X0000184 = (sin(X0000181)) * (sin(X0000182));
	float X0000185 = cos(X0000182);
	X0000009_mia_material(X0000173, X0000180, X0000183, X0000184, X0000185);
}

void X0000012_mia_material(
	inout float3 X0000186,
	in float3 X0000187,
	in float3 X0000188,
	in float3 X0000189,
	in float X0000190,
	in float X0000191,
	in float X0000192)
{
	float X0000193 = dot(X0000188, X0000187);
	float3 X0000194 = X0000188 - (X0000193 * X0000187);
	X0000194 = (normalize(X0000194));
	float3 X0000195 = cross(X0000187, X0000194);
	X0000186 = (((X0000190 * X0000194) + (X0000191 * X0000195)) + (X0000192 * X0000187));
}

void X0000013_mia_material(
	inout float3 X0000196,
	in float3 X0000197,
	in float3 X0000198,
	in float3 X0000199,
	in float X0000200,
	in float3 X0000201,
	in float3 X0000202,
	in float X0000203,
	in float X0000204,
	in float2 X0000205)
{
	float3 X0000206 = float3(0.0, 0.0, 0.0);
	X0000206 = (reflect(X0000197, X0000198));
	float X0000207 = atan2((X0000203 * (cos(((2.0 * 3.14159265358979323846f) * X0000205.x)))), (X0000204 * (sin(((2.0 * 3.14159265358979323846f) * X0000205.x)))));
	float X0000208 = (cos(X0000207)) * X0000203;
	float X0000209 = (sin(X0000207)) * X0000204;
	float X0000210 = atan((sqrt(((-(log((1.0 - X0000205.y)))) / ((X0000208 * X0000208) + (X0000209 * X0000209))))));
	float X0000211 = (cos(X0000207)) * (sin(X0000210));
	float X0000212 = (sin(X0000207)) * (sin(X0000210));
	float X0000213 = cos(X0000210);
	X0000012_mia_material(X0000196, X0000206, X0000201, X0000202, X0000211, X0000212, X0000213);
	float X0000214 = dot(X0000196, X0000199);
	if (X0000214 < 0.0)
	{
		float3 X0000215 = X0000199;
		X0000215 *= ((-2.0) * X0000214);
		X0000196 = (X0000196 + X0000215);
	}
}

float X0000014_mia_material(
	inout int X0000216,
	in float X0000217,
	in State state)
{
	if (false)
	{
		X0000216 = 1;
	}
	if (X0000216 > 1)
	{
		X0000216 *= 1;
	}
	if (X0000216 < 1)
	{
		X0000216 = 1;
	}
	return X0000217 * (state.importance);
}

void X0000015_mia_material(
	inout float3 X0000219,
	in float3 X0000220,
	in float3 X0000221,
	in float3 X0000222,
	in float X0000223,
	in float3 X0000224,
	in float3 X0000225,
	in float X0000226,
	in float X0000227,
	in float2 X0000228)
{
	if (X0000226 >= 1.0)
	{
		X0000219 = (reflect(X0000220, X0000221));
	}
	else
	{
		if (X0000226 <= 0.0)
		{
			X0000010_mia_material(X0000219, X0000221, X0000228);
		}
		else
		{
			float X0000229 = X0000006_mia_material(X0000226);
			float3 X0000230 = -X0000221;
			float X0000231 = -1.0;
			if ((abs((X0000227 - 1.0))) < 0.01)
			{
				X0000011_mia_material(X0000219, X0000230, X0000221, X0000229, X0000228);
			}
			else
			{
				X0000013_mia_material(X0000219, X0000230, X0000221, X0000222, X0000231, X0000224, X0000225, X0000229, (X0000229 * X0000227), X0000228);
			}
			X0000219 += X0000221;
			X0000219 = (normalize(X0000219));
			float3 X0000232 = X0000219;
			X0000231 = (dot(X0000220, X0000232));
			float3 X0000233 = X0000220 - ((X0000232 * X0000231) * 2.0);
			float X0000234 = dot(X0000222, X0000233);
			X0000219 = (reflect(X0000220, X0000232));
			if (X0000234 < (-0.35))
			{
				X0000234 = (dot(X0000233, X0000222));
				X0000219 = (X0000233 - ((X0000222 * X0000234) * 2.0));
			}
		}
	}
}

void X0000016_mia_material(
	inout float4 X0000235,
	in bool X0000236,
	in float X0000237,
	in bool X0000238,
	in float4 X0000239,
	in float3 X0000240,
	in float3 X0000241,
	in float3 X0000242,
	in float3 X0000243,
	in float X0000244,
	in int X0000245,
	in float X0000246,
	in float X0000247,
	in float3 X0000248,
	in float3 X0000249,
	in float X0000250,
	in float X0000251,
	in State state)
{
	float4 X0000253 = float4(0.0, 0.0, 0.0, 0.0);
	float X0000254 = 0.0;
	float2 X0000255;
	int X0000256 = X0000245;
	float X0000257 = X0000246;
	float X0000258 = X0000247;
	if ((X0000256 <= 0) || (X0000257 >= 1.0))
	{
		X0000256 = 1;
		X0000257 = 1.0;
		X0000258 = 1.0;
	}
	float X0000259 = X0000014_mia_material(X0000256, X0000251, (state));
	
	if (X0000259 >= (X0000250 * 0.0))
	{
		
			{
				X0000254 += 1.0;
				X0000255 = float2(0.0, 0.0);
				float3 X0000262 = float3(0.0, 0.0, 0.0);
				float X0000263 = X0000246;
				X0000015_mia_material(X0000262, X0000241, X0000242, X0000243, X0000244, X0000248, X0000249, X0000263, X0000258, X0000255);
				float4 X0000264;
				Ray X0000265;
				Ray X0000266;
				Ray X0000267;
				int X0000268;
				X0000265 = (Ray(X0000240, X0000262));
				
				;
				if (X0000263 < 1.0)
				{
					;
				}
				else
				{
					;
				}
				float X0000270 = 0.0;
				if (X0000236)
				{
					X0000270 = X0000237;
				}
				if (X0000270 > 0.0)
				{
					;
				}
				;
				X0000268 = 437331;
				float X0000271 = 0.0;
				if (false)
				{
					float4 X0000272 = float4(0.0, 0.0, 0.0, 0.0);
					if (X0000236)
					{
						if (X0000238)
						{
							X0000272 = X0000239;
						}
						else
						{
							X0000272 = (__trace_environment((state), X0000265));
						}
						if (X0000271 > 0.0)
						{
							if ((X0000270 > 0.0) && (X0000271 < X0000270))
							{
								float X0000273 = pow((1.0 - (X0000271 / X0000270)), 2.0);
								float X0000274 = 1.0 - X0000273;
								X0000253 += ((X0000264 * X0000273) + (X0000272 * X0000274));
							}
							else
							{
								X0000253 += X0000264;
							}
						}
						else
						{
							X0000253 += X0000272;
						}
					}
					else
					{
						X0000253 += X0000264;
					}
				}
				else
				{
					X0000253 += (__trace_environment((state), X0000265));
				}
			}
		if (X0000254 > 0.0)
		{
			X0000235 = (X0000253 / X0000254);
		}
	}
}

void X0000017_mia_material(
	inout float4 X0000275,
	in bool X0000276,
	in float X0000277,
	in bool X0000278,
	in float4 X0000279,
	in float3 X0000280,
	in float3 X0000281,
	in float3 X0000282,
	in float3 X0000283,
	in float X0000284,
	in float X0000285,
	in bool X0000286,
	in int X0000287,
	in float X0000288,
	in float X0000289,
	in float3 X0000290,
	in float3 X0000291,
	in float X0000292,
	in float X0000293,
	in State state)
{
	if (X0000276)
	{
		
	}
	if (X0000285 > 0.0)
	{
		if (!X0000286)
		{
			X0000016_mia_material(X0000275, X0000276, X0000277, X0000278, X0000279, X0000280, X0000281, X0000282, X0000283, X0000284, X0000287, X0000288, X0000289, X0000290, X0000291, X0000292, X0000293, (state));
		}
	}
}

void X0000018_mia_material(
	inout float4 X0000295,
	in bool X0000296,
	in float X0000297,
	in bool X0000298,
	in float4 X0000299,
	in float3 X0000300,
	in float3 X0000301,
	in float3 X0000302,
	in float3 X0000303,
	in float X0000304,
	in bool X0000305,
	in float4 X0000306,
	in float X0000307,
	in bool X0000308,
	in int X0000309,
	in float X0000310,
	in float X0000311,
	in float3 X0000312,
	in float3 X0000313,
	in float X0000314,
	in State state)
{
	if (X0000305)
	{
	}
	else
	{
		X0000017_mia_material(X0000295, X0000296, X0000297, X0000298, X0000299, X0000300, X0000301, X0000302, X0000303, X0000304, X0000307, X0000308, X0000309, X0000310, X0000311, X0000312, X0000313, X0000314, X0000306.a, (state));
	}
	X0000295.r *= X0000306.r;
	X0000295.g *= X0000306.g;
	X0000295.b *= X0000306.b;
}

bool X0000019_mia_material(
	inout float3 X0000316,
	in float X0000317,
	in float X0000318,
	in float3 X0000319,
	in float3 X0000320,
	in float3 X0000321,
	in float X0000322)
{
	if (X0000318 <= 0.0)
	{
		return false;
	}
	else
	{
		float X0000323 = X0000317 / X0000318;
		float X0000324 = 1.0 - ((X0000323 * X0000323) * (1.0 - (X0000322 * X0000322)));
		if (X0000324 < 0.0)
		{
			return false;
		}
		else
		{
			if (X0000324 == 0.0)
			{
				X0000316 == X0000319;
				return true;
			}
			else
			{
				X0000324 = (((-X0000323) * X0000322) - (sqrt(X0000324)));
				X0000316 = ((X0000324 * X0000320) + (X0000323 * X0000319));
				if ((dot(X0000316, X0000321)) > 0.0)
				{
					X0000316 = X0000319;
					return true;
				}
				else
				{
					X0000316 = (normalize(X0000316));
					return true;
				}
			}
		}
	}
}

void X0000020_mia_material(
	inout float3 X0000325,
	in float3 X0000326,
	in float2 X0000327)
{
	X0000010_mia_material(X0000325, X0000326, X0000327);
	X0000325 = (-X0000325);
}

bool X0000021_mia_material(
	inout float3 X0000328,
	in float X0000329,
	in float X0000330,
	in float3 X0000331,
	in float3 X0000332,
	in float3 X0000333,
	in float X0000334,
	in float X0000335,
	in float2 X0000336)
{
	float3 X0000337 = float3(0.0, 0.0, 0.0);
	float X0000338 = 1000000000000000000000000000000000000.0;
	float X0000339;
	if (!(X0000019_mia_material(X0000337, X0000329, X0000330, X0000331, X0000332, X0000333, X0000334)))
	{
		return false;
	}
	if (X0000335 > 0.0)
	{
		X0000339 = (1.0 / X0000335);
	}
	else
	{
		X0000339 = X0000338;
	}
	float X0000340 = (2.0 * 3.14159265358979323846f) * X0000336.x;
	float X0000341 = atan((X0000339 * (sqrt((-(log((1.0 - X0000336.y))))))));
	float X0000342 = (cos(X0000340)) * (sin(X0000341));
	float X0000343 = (sin(X0000340)) * (sin(X0000341));
	float X0000344 = cos(X0000341);
	X0000009_mia_material(X0000328, X0000337, X0000342, X0000343, X0000344);
	return (dot(X0000328, X0000333)) < 0.0;
}

bool X0000022_mia_material(
	inout float3 X0000345,
	in float X0000346,
	in float X0000347,
	in float3 X0000348,
	in float3 X0000349,
	in float3 X0000350,
	in float X0000351,
	in float3 X0000352,
	in float3 X0000353,
	in float X0000354,
	in float X0000355,
	in float2 X0000356)
{
	float3 X0000357 = float3(0.0, 0.0, 0.0);
	if (!(X0000019_mia_material(X0000357, X0000346, X0000347, X0000348, X0000349, X0000350, X0000351)))
	{
		return false;
	}
	float X0000358 = atan2((X0000354 * (cos(((2.0 * 3.14159265358979323846f) * X0000356.x)))), (X0000355 * (sin(((2.0 * 3.14159265358979323846f) * X0000356.x)))));
	float X0000359 = (cos(X0000358)) * X0000354;
	float X0000360 = (sin(X0000358)) * X0000355;
	float X0000361 = atan((sqrt(((-(log((1.0 - X0000356.x)))) / ((X0000359 * X0000359) + (X0000360 * X0000360))))));
	float X0000362 = (cos(X0000358)) * (sin(X0000361));
	float X0000363 = (sin(X0000358)) * (sin(X0000361));
	float X0000364 = cos(X0000361);
	X0000012_mia_material(X0000345, X0000357, X0000352, X0000353, X0000362, X0000363, X0000364);
	return (dot(X0000345, X0000350)) < 0.0;
}

bool X0000023_mia_material(
	inout float3 X0000365,
	in float X0000366,
	in float X0000367,
	in float3 X0000368,
	in float3 X0000369,
	in float3 X0000370,
	in float X0000371)
{
	return X0000019_mia_material(X0000365, X0000366, X0000367, X0000368, X0000369, X0000370, X0000371);
}

bool X0000024_mia_material(
	inout float3 X0000372,
	in bool X0000373,
	in float3 X0000374,
	in float3 X0000375,
	in float3 X0000376,
	in float X0000377,
	in bool X0000378,
	in float X0000379,
	in float3 X0000380,
	in float3 X0000381,
	in float X0000382,
	in float X0000383,
	in float2 X0000384)
{
	float X0000385 = 1.0;
	float X0000386 = 1.0;
	if (!X0000378)
	{
		if (X0000373)
		{
			X0000385 = X0000379;
		}
		else
		{
			X0000386 = X0000379;
		}
	}
	if (X0000382 >= 1.0)
	{
		return X0000023_mia_material(X0000372, X0000385, X0000386, X0000374, X0000375, X0000376, X0000377);
	}
	if (X0000382 <= 0.0)
	{
		X0000020_mia_material(X0000372, X0000375, X0000384);
		return true;
	}
	float X0000387 = X0000006_mia_material(X0000382);
	if ((abs((X0000383 - 1.0))) < 0.01)
	{
		return X0000021_mia_material(X0000372, X0000385, X0000386, X0000374, X0000375, X0000376, X0000377, X0000387, X0000384);
	}
	return X0000022_mia_material(X0000372, X0000385, X0000386, X0000374, X0000375, X0000376, X0000377, X0000380, X0000381, X0000387, (X0000387 * X0000383), X0000384);
}

void X0000025_mia_material(
	inout float4 X0000388,
	in bool X0000389,
	in float3 X0000390,
	in float3 X0000391,
	in float3 X0000392,
	in float3 X0000393,
	in float X0000394,
	in int X0000395,
	in float X0000396,
	in float X0000397,
	in bool X0000398,
	in float X0000399,
	in float3 X0000400,
	in float3 X0000401,
	in float X0000402,
	in float X0000403,
	in State state)
{
	float4 X0000405 = float4(0.0, 0.0, 0.0, 0.0);
	float X0000406 = 0.0;
	float2 X0000407;
	int X0000408 = X0000395;
	float X0000409 = X0000396;
	float X0000410 = X0000397;
	if ((X0000408 <= 0) || (X0000409 >= 1.0))
	{
		X0000408 = 1;
		X0000409 = 1.0;
		X0000410 = 1.0;
	}
	float X0000411 = X0000014_mia_material(X0000408, X0000403, (state));
	
	if (X0000411 >= (X0000402 * 0.0))
	{
		
			{
				X0000406 += 1.0;
				X0000407 = float2(0.0, 0.0);
				float3 X0000414 = float3(0.0, 0.0, 0.0);
				float X0000415 = X0000396;
				bool X0000416 = X0000024_mia_material(X0000414, X0000389, X0000391, X0000392, X0000393, X0000394, X0000398, X0000399, X0000400, X0000401, X0000415, X0000410, X0000407);
				if (!X0000416)
				{
					X0000015_mia_material(X0000414, X0000391, X0000392, X0000393, X0000394, X0000400, X0000401, X0000415, X0000410, X0000407);
					float4 X0000417;
					Ray X0000418;
					Ray X0000419;
					Ray X0000420;
					int X0000421;
					X0000418 = (Ray(X0000390, X0000414));
					
					;
					if (X0000415 < 1.0)
					{
						;
					}
					else
					{
						;
					}
					;
					X0000421 = 437331;
					if (false)
					{
						X0000405.r += X0000417.r;
						X0000405.g += X0000417.g;
						X0000405.b += X0000417.b;
						X0000405.a += 1.0;
					}
				}
				else
				{
					float4 X0000423;
					Ray X0000424;
					Ray X0000425;
					Ray X0000426;
					int X0000427;
					X0000424 = (Ray(X0000390, X0000414));
					
					;
					;
					;
					X0000427 = 437331;
					if (false)
					{
						X0000405 += X0000423;
					}
					else
					{
						X0000405 += (__trace_environment((state), X0000424));
					}
				}
			}
		if (X0000406 > 0.0)
		{
			X0000388 = (X0000405 / X0000406);
		}
	}
}

void X0000026_mia_material(
	inout float4 X0000429,
	in bool X0000430,
	in float3 X0000431,
	in float3 X0000432,
	in float3 X0000433,
	in float3 X0000434,
	in float X0000435,
	in bool X0000436,
	in float4 X0000437,
	in int X0000438,
	in float X0000439,
	in float X0000440,
	in bool X0000441,
	in float X0000442,
	in float3 X0000443,
	in float3 X0000444,
	in float X0000445,
	in State state)
{
	if (!X0000436)
	{
		X0000025_mia_material(X0000429, X0000430, X0000431, X0000432, X0000433, X0000434, X0000435, X0000438, X0000439, X0000440, X0000441, X0000442, X0000443, X0000444, X0000445, X0000437.a, (state));
	}
	X0000429.r *= X0000437.r;
	X0000429.g *= X0000437.g;
	X0000429.b *= X0000437.b;
}

void mia_material_main(
	float diffuse_weight,
	float4 diffuse,
	float diffuse_roughness,
	float reflectivity,
	float4 refl_color,
	float refl_gloss,
	int refl_gloss_samples,
	bool refl_interpolate,
	bool refl_hl_only,
	bool refl_is_metal,
	float transparency,
	float4 refr_color,
	float refr_gloss,
	float refr_ior,
	int refr_gloss_samples,
	bool refr_interpolate,
	bool refr_translucency,
	float4 refr_trans_color,
	float refr_trans_weight,
	float anisotropy,
	float anisotropy_rotation,
	int anisotropy_channel,
	bool brdf_fresnel,
	float brdf_0_degree_refl,
	float brdf_90_degree_refl,
	float brdf_curve,
	bool brdf_conserve_energy,
	int intr_grid_density,
	int intr_refl_samples,
	bool intr_refl_ddist_on,
	float intr_refl_ddist,
	int intr_refr_samples,
	bool single_env_sample,
	bool refl_falloff_on,
	float refl_falloff_dist,
	bool refl_falloff_color_on,
	float4 refl_falloff_color,
	int refl_depth,
	float refl_cutoff,
	bool refr_falloff_on,
	float refr_falloff_dist,
	bool refr_falloff_color_on,
	float4 refr_falloff_color,
	int refr_depth,
	float refr_cutoff,
	float indirect_multiplier,
	float fg_quality,
	float fg_quality_w,
	bool ao_on,
	int ao_samples,
	float ao_distance,
	float4 ao_dark,
	float4 ao_ambient,
	bool ao_do_details,
	bool thin_walled,
	bool no_visible_area_hl,
	bool skip_inside_refl,
	bool do_refractive_caustics,
	bool backface_cull,
	bool propagate_alpha,
	float hl_vs_refl_balance,
	float cutout_opacity,
	float4 additional_color,
	int bump,
	bool no_diffuse_bump,
	int mode,
	State state,
	out float4 result)
{
	{
		result = (float4(0.0, 0.0, 0.0, 0.0));
		float4 X0000447 = float4(0.0, 0.0, 0.0, 0.0);
		float4 X0000448 = float4(0.0, 0.0, 0.0, 0.0);
		float4 X0000449 = float4(0.0, 0.0, 0.0, 0.0);
		float4 X0000450 = float4(0.0, 0.0, 0.0, 0.0);
		float4 X0000451 = float4(0.0, 0.0, 0.0, 0.0);
		float4 X0000452 = float4(0.0, 0.0, 0.0, 0.0);
		float4 X0000453 = float4(0.0, 0.0, 0.0, 0.0);
		float X0000454 = cutout_opacity;
		if (backface_cull && (state.backside))
		{
			X0000454 = 0.0;
		}
		if (X0000454 < 0.01)
		{
			Ray X0000455;
			Ray X0000456;
			Ray X0000457;
			int X0000458;
			
			X0000455 = (Ray((state.position), (state.direction)));
			;
			if (false)
			{
				result += X0000453;
			}
			else
			{
				result += (__trace_environment((state), X0000455));
			}
		}
		else
		{
			float3 X0000460 = float3(0.0, 0.0, 0.0);
			float3 X0000461 = float3(0.0, 0.0, 0.0);
			float X0000462 = 0.0;
			float3 X0000463 = float3(0.0, 0.0, 0.0);
			float3 X0000464 = float3(0.0, 0.0, 0.0);
			X0000001_mia_material(X0000460, X0000461, X0000462, X0000463, X0000464, (state.direction), (state.normal), anisotropy_rotation, anisotropy_channel);
			bool X0000465 = false;
			bool X0000466 = false;
			float X0000467 = 0.0;
			float4 X0000468 = float4(0.0, 0.0, 0.0, 0.0);
			float4 X0000469 = float4(0.0, 0.0, 0.0, 0.0);
			float4 X0000470 = float4(0.0, 0.0, 0.0, 0.0);
			float X0000471 = 0.0;
			bool X0000472 = false;
			bool X0000473 = false;
			float X0000474 = 0.0;
			float4 X0000475 = float4(0.0, 0.0, 0.0, 0.0);
			bool X0000476 = false;
			bool X0000477 = false;
			float X0000478 = 0.0;
			int X0000479 = 0;
			float X0000480 = 0.0;
			float X0000481 = 0.0;
			float X0000482 = 0.0;
			int X0000483 = 0;
			float X0000484 = 0.0;
			float X0000485 = 0.0;
			int X0000486 = 0;
			float X0000487 = 0.0;
			bool X0000488 = false;
			float X0000489 = 0.0;
			bool X0000490 = false;
			float4 X0000491 = float4(0.0, 0.0, 0.0, 0.0);
			bool X0000492 = false;
			bool X0000493 = false;
			float X0000494 = 0.0;
			X0000004_mia_material(X0000465, X0000466, X0000467, X0000468, X0000469, X0000470, X0000471, X0000472, X0000473, X0000474, X0000475, X0000476, X0000477, X0000478, X0000479, X0000480, X0000481, X0000482, X0000483, X0000484, X0000485, X0000486, X0000487, X0000488, X0000489, X0000490, X0000491, X0000492, X0000493, X0000494, (state.direction), (state.normal), (state.dot_nd), (state.backside), diffuse_weight, diffuse, reflectivity, refl_color, refl_gloss, refl_gloss_samples, refl_interpolate, refl_hl_only, refl_is_metal, transparency, refr_color, refr_gloss, refr_ior, refr_gloss_samples, refr_interpolate, refr_translucency, refr_trans_color, refr_trans_weight, anisotropy, brdf_fresnel, brdf_0_degree_refl, brdf_90_degree_refl, brdf_curve, brdf_conserve_energy, intr_refl_ddist_on, intr_refl_ddist, single_env_sample, refl_cutoff, refr_falloff_on, refr_falloff_dist, refr_falloff_color_on, refr_falloff_color, refr_cutoff, fg_quality, fg_quality_w, ao_on, ao_samples, ao_distance, ao_do_details, thin_walled, skip_inside_refl, hl_vs_refl_balance, no_diffuse_bump);
			float4 X0000495 = float4(1.0, 1.0, 1.0, 1.0);
			if (((X0000468.a > 0.0) || (X0000469.a > 0.0)) || (X0000475.a > 0.0))
			{
				Light_iterator X0000496;
				for (int light_index=0;
				     light_index < lights.length;
				     light_index++)
				{
					X0000496 = lights[light_index].eval(state); X0000496.count = light_index;
					float X0000497 = dot(X0000496.direction, X0000460);
					if (X0000497 >= 0.0)
					{
						float X0000498 = dot(X0000496.direction, X0000461);
						X0000498 *= (smoothstep(0.0, 0.25, X0000497));
						float X0000499 = saturate(X0000498);
						if (X0000465)
						{
							X0000499 = (dot(X0000496.direction, X0000460));
						}
						if (X0000499 > 0.0)
						{
							if (diffuse_roughness <= 0.0)
							{
								X0000448 += ((X0000499 * X0000468) * X0000496.contribution);
							}
							else
							{
								float4 X0000500 = X0000005_mia_material(X0000496, X0000468, (state.direction), (state.normal), diffuse_roughness);
								X0000448 += ((X0000499 * X0000500) * X0000496.contribution);
							}
						}
						float X0000501 = 0.0;
						float X0000502 = X0000006_mia_material(X0000482);
						float X0000503 = anisotropy * X0000502;
						if (X0000502 >= 80.0)
						{
							X0000502 = (80.0 + (sqrt((X0000502 - 80.0))));
						}
						if (X0000503 >= 80.0)
						{
							X0000503 = (80.0 + (sqrt((X0000503 - 80.0))));
						}
						X0000501 = ((((X0000007_mia_material((state.direction), X0000496.direction, (state.normal), X0000463, X0000464, X0000502, X0000503)) * 0.5) + ((X0000007_mia_material((state.direction), X0000496.direction, (state.normal), X0000463, X0000464, (X0000502 / 2.0), (X0000503 / 2.0))) * 1.0)) + ((X0000007_mia_material((state.direction), X0000496.direction, (state.normal), X0000463, X0000464, (X0000502 / 4.0), (X0000503 / 4.0))) * 1.5));
						X0000501 *= (X0000498 * X0000481);
						X0000501 *= (sqrt((state.importance)));
						X0000449 += ((X0000496.contribution * X0000469) * X0000501);
					}
				}
				
				float X0000505 = dot(X0000468.rgb, (float3((1. / 3))));
				;
				X0000448 += (X0000468 * (__scene_ambient));
				(state.normal) = (-(state.normal));
				Light_iterator X0000506;
				for (int light_index=0;
				     light_index < lights.length;
				     light_index++)
				{
					X0000506 = lights[light_index].eval(state); X0000506.count = light_index;
					if (X0000475.a > 0.0)
					{
						float X0000507 = X0000506.dot_nl;
						if (X0000465)
						{
							X0000507 = (dot(X0000496.direction, X0000460));
						}
						if (X0000507 > 0.0)
						{
							X0000450.r += ((X0000506.contribution.r * X0000507) * X0000475.r);
							X0000450.g += ((X0000506.contribution.g * X0000507) * X0000475.g);
							X0000450.b += ((X0000506.contribution.b * X0000507) * X0000475.b);
						}
					}
				}
				(state.normal) = (-(state.normal));
			}
			if (X0000469.a > 0.0)
			{
				X0000018_mia_material(X0000451, refl_falloff_on, refl_falloff_dist, refl_falloff_color_on, refl_falloff_color, (state.position), (state.direction), (state.normal), (state.geom_normal), (state.dot_nd), X0000466, X0000469, X0000474, X0000492, X0000483, X0000482, X0000467, X0000463, X0000464, X0000484, (state));
			}
			if (X0000470.a > 0.0)
			{
				X0000026_mia_material(X0000452, (state.backside), (state.position), (state.direction), (state.normal), (state.geom_normal), (state.dot_nd), X0000493, X0000470, X0000486, X0000485, X0000467, X0000472, X0000471, X0000463, X0000464, X0000487, (state));
			}
			result = (((((X0000447 + X0000448) + X0000449) + X0000450) + X0000451) + X0000452);
			if (propagate_alpha)
			{
				result.a = ((result.a * (1.0 - X0000470.a)) + (X0000452.a * X0000470.a));
			}
			else
			{
				result.a = 1.0;
			}
			if (additional_color.r > 0.0)
			{
				result.r += additional_color.r;
			}
			if (additional_color.g > 0.0)
			{
				result.g += additional_color.g;
			}
			if (additional_color.b > 0.0)
			{
				result.b += additional_color.b;
			}
			result.r *= X0000495.r;
			result.g *= X0000495.g;
			result.b *= X0000495.b;
			result.a = ((result.a * X0000495.a) + (1.0 - X0000495.a));
			result.r *= X0000454;
			result.g *= X0000454;
			result.b *= X0000454;
			result.a *= X0000454;
		}
	}
}

//
// The following method is the root function of the shader graph
//
float4 mia_material_1_eval(State state)
{
	float4 result;
	mia_material_main(diffuse_weight, diffuse, diffuse_roughness, reflectivity, refl_color, refl_gloss, 8, false, refl_hl_only, refl_is_metal, transparency, refr_color, refr_gloss, refr_ior, 8, false, refr_translucency, refr_trans_color, refr_trans_weight, anisotropy, anisotropy_rotation, -1, brdf_fresnel, brdf_0_degree_refl, brdf_90_degree_refl, brdf_curve, brdf_conserve_energy, 2, 2, false, 0.000000, 2, false, false, 0.000000, false, (float4(0.000000, 0.000000, 0.000000, 1.000000)), 5, 0.010000, false, 0.000000, false, (float4(0.000000, 0.000000, 0.000000, 1.000000)), 5, 0.010000, 1.000000, 1.000000, 1.000000, ao_on, 16, ao_distance, ao_dark, ao_ambient, ao_do_details, thin_walled, true, skip_inside_refl, false, backface_cull, false, hl_vs_refl_balance, cutout_opacity, (float4(0.000000, 0.000000, 0.000000, 1.000000)), 0, no_diffuse_bump, 0, (state), result);
	return result;
}

//
// This function is the main method of the fragment shader. It initializes the
// values in the state structure that are used by nodes in the shader graph
// and produces the final result of the shader.
//
float4 fragment_main(
	Vert2frag fs_in) : COLOR
{
	State state;
	state.position = fs_in.position;
	float __sign_fcolor = sign(fs_in.fcolor.r - 0.5);
	state.normal = __sign_fcolor * normalize(fs_in.normal);
	state.backside = __sign_fcolor < 0.0;
	state.geom_normal = state.normal;
	state.ray_length = length(state.position);
	state.direction = state.position/state.ray_length;
	state.dot_nd = dot(state.direction, state.normal);
	if (state.dot_nd > 0f) {
		state.dot_nd = -state.dot_nd;
		state.normal = -state.normal;
		state.geom_normal = -state.geom_normal;
	}
	state.importance = 1.0;
	return mia_material_1_eval(state);
}

//
// The following define the default technique and pass of the effect.
//
technique T0
{
	pass P0
	{
		DepthTestEnable = true;
		DepthMask       = true;
		CullFaceEnable  = false;
		VertexShader = compile vp40 vertex_main();
		PixelShader  = compile fp40 fragment_main();
	}
}
//
// The following define the default technique and pass of the effect.
//
technique T1
{
	pass P0
	{
		DepthTestEnable = true;
		DepthMask       = true;
		CullFaceEnable  = false;
		VertexShader = compile glslv vertex_main();
		PixelShader  = compile glslf fragment_main();
	}
}

// So far, Directional Light has been ported to be supported by			       
// both Mental mill and Catia.								       
// 											       
// To do: Implement the other light types as well for Catia				       
											       
#ifndef __WORLD_TO_CAMERA								       
#define __WORLD_TO_CAMERA								       
float4x4 __world_to_camera : View;							       
#endif											       
											       
											       
struct SLightDir : Light								       
{											       
											       
    //											       
    // The following are free parameters of the shader that should be set by the	       
    // application at runtime.								       
    //											       
											       
    const float3 LightPos;								       
    const float3 LightDir;								       
    const float3 LightColor;								       
    const float3 LightColorSpec;							       
    const float3 lightI_SCos_SExp;							       
											       
    //void Light_directional_main(float3 color, State state, out float4 result)								       
    //{											       
	  //  result = float4(LightColor.xyz, 1.0) * 3.141592;				       
    //}											       
    Light_iterator eval(State state)							       
    {											       
	    state.light_to_surface = mul((float3x3)__world_to_camera, -LightDir); // catmod	       
	    state.light_distance = length(state.light_to_surface);				       
	    state.light_to_surface /= state.light_distance;					       
	    state.light_dotnl = dot(-state.light_to_surface, state.normal);			       

	    float4 result;									       
	    //Light_directional_main(LightColor, (state), result);	
	    result	= float4(LightColor, 1.0);					       
	    			       
	    Light_iterator __light_out;							       
	    __light_out.raw_contribution = result;						       
	    __light_out.contribution = __light_out.raw_contribution;			       
	    __light_out._point     = LightPos;						       
	    __light_out.distance  = state.light_distance;					       
	    __light_out.dot_nl    = state.light_dotnl;					       
	    __light_out.direction = -state.light_to_surface;				       
	    return __light_out;								       
    }											       
											       
};											       
											       
											       
// ---------------- implementation of point light --------------			       
struct SLightPoint : Light								       
{											       
    const float3 LightPos;							       
    const float3 LightDir;								       
    const float3 LightColor;
    const float3 LightColorSpec;							       
    const float3 lightI_SCos_SExp;							       
											       
    // the catia function evaluation							       
    Light_iterator eval(State state)							       
    {											       
	    // BRING LIGHTS TO CAMERASPACE!!!!						       
	    float3 lightpos_camspace = mul(__world_to_camera, float4((LightPos).xyz, 1.0)).xyz;    
	    state.light_to_surface   = state.position - lightpos_camspace;			       
	    state.light_distance     =  length(state.light_to_surface);			       
	    state.light_to_surface   = normalize(state.light_to_surface);			       
	    state.light_dotnl        = dot(-state.light_to_surface, state.normal);		       
    											       
	    float4 result;									       
	    //result	= float4(LightColor, 1.0) * 3.141592; //rbx				       
	    result	= float4(LightColor, 1.0);					       
	    // would do light-shader evaluation here...					       
    											       
	    Light_iterator __light_out;							       
	    __light_out.raw_contribution   = result;					       
	    __light_out.contribution       = __light_out.raw_contribution;			       
	    __light_out._point             = lightpos_camspace;				       
	    __light_out.distance           = state.light_distance;				       
	    __light_out.dot_nl             = state.light_dotnl;				       
	    __light_out.direction          = -state.light_to_surface;			       
	    return __light_out;								       
    }											       
};											       
											       

// ---------------- implementation of spot light --------------			       
struct SLightSpot : Light								       
{											       
    const float3 LightPos;						       
    const float3 LightDir;								       
    const float3 LightColor;
    const float3 LightColorSpec;							       
    const float3 lightI_SCos_SExp;							       
											       
    // the catia function evaluation							       
    Light_iterator eval(State state)							       
    {											       
	    // BRING LIGHTS TO CAMERASPACE!!!!						       
	    float3 lightpos_camspace = mul(__world_to_camera, float4((LightPos).xyz, 1.0)).xyz;    
	    state.light_to_surface   = state.position - lightpos_camspace;			       
	    state.light_distance     =  length(state.light_to_surface);			       
	    state.light_to_surface   = normalize(state.light_to_surface);			       
	    state.light_dotnl        = dot(-state.light_to_surface, state.normal);		       
    											       
	    float4 result;									       
	    //result	= float4(LightColor, 1.0) * 3.141592; //rbx				       
	    result	= float4(LightColor, 1.0);					       
	    // would do light-shader evaluation here...					       

	    // cone 
	    float3 lightdir_camspace = mul((float3x3)__world_to_camera, LightDir);	       
	    float d = dot(state.light_to_surface, lightdir_camspace);
      if (d < 0)
      {
        result.rgb = 0;
      }
      if (d < lightI_SCos_SExp.y)
      {
        result.rgb = 0;
      }
    										       
	    Light_iterator __light_out;							       
	    __light_out.raw_contribution   = result;					       
	    __light_out.contribution       = __light_out.raw_contribution;			       
	    __light_out._point             = lightpos_camspace;				       
	    __light_out.distance           = state.light_distance;				       
	    __light_out.dot_nl             = state.light_dotnl;				       
	    __light_out.direction          = -state.light_to_surface;			       
	    return __light_out;								       
    }											       
};											       
