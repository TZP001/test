/**
 * © Dassault Systèmes 2008 – Do not reproduce, copy or use without a license from Dassault Systèmes
 * CGFX Shader for CATIA V5
 * Author: Jerome Derel
 * Date: 21.05.2008
 */


/******************************************************************/
/* DATA - STRUCTURES */
/******************************************************************/

struct LIGHT_INFOS
{
	float3 position;
	float3 direction;
	float4 ambient;
	float4 diffuse;
	float4 specular;
};

struct MATERIAL_INFOS
{
	float3 position;
	float3 normal;
	float3 tangent;
	float3 binormal;
};

struct CAMERA_INFOS
{
	float3 position;
	float3 direction;
};


struct LIGHT_RESULT
{
	float4 contribution;
};

struct ILLUMINATION_RESULT
{
	float4 ambient;
	float4 diffuse;
	float4 specular;
};


/******************************************************************/
/* LIGHT - PARAMETERS */
/******************************************************************/

#ifdef IN_FXCOMPOSER2
/* Simple lighting implementation in FXC2 */
float3 _LightPos : Position
<
	string Object = "PointLight0";
	string Space = "World";
	string UIName = "Light0 Light_position";
> = float3(0.0f,0.0f,0.0f);

float4 _LightAmbient
<
	string UIName = "Light0 Ambient Color";
	string UIWidget = "Color";
> = float4(0.2f,0.2f,0.2f,1.0f);

float4 _LightDiffuse
<
	string UIName = "Light0 Diffuse Color";
	string UIWidget = "Color";
> = float4(0.5f,0.5f,0.5f,1.0f);

float4 _LightSpecular
<
	string UIName = "Light0 Specular Color";
	string UIWidget = "Color";
> = float4(0.8f,0.8f,0.8f,1.0f);
#endif


/******************************************************************/
/* LIGHT - STRUCTURES */
/******************************************************************/

interface Light
{
	float3 getPosition(MATERIAL_INFOS material_infos);
	float3 getDirection(MATERIAL_INFOS material_infos);
	float4 getAmbient();
	float4 getDiffuse();
	float4 getSpecular();
	LIGHT_RESULT compute(MATERIAL_INFOS material_infos);
};

struct SLightDir : Light
{
	const float3 LightPos;
	const float3 LightDir;
	const float3 LightUp;
	const float3 LightRight;
	
	const float4 LightAmbient;
	const float4 LightDiffuse;
	const float4 LightSpecular;
	
	const float LightAxialFalloffStart;
	const float LightAxialFalloffEnd;
	const float LightAxialFalloffConstant;
	const float LightAxialFalloffLinear;
	const float LightAxialFalloffQuadratic;
	
	const float LightRadialInnerCone; /* cosf(InnerConeAngle * 3.14159f / 180.0f) */
	const float LightRadialOuterCone; /* cosf(OuterConeAngle * 3.14159f / 180.0f) */
	const float LightRadialFalloffExponent;
	
	const float LightAreaType;
	const float LightAreaStatus;
	const float2 LightAreaGeometry;
	
	
	float3 getPosition(MATERIAL_INFOS material_infos)
	{
		return LightPos;
	}
	
	float3 getDirection(MATERIAL_INFOS material_infos)
	{
		return LightDir;
	}
	
	float4 getAmbient()
	{
		return LightAmbient;
	}
	
	float4 getDiffuse()
	{
		return LightDiffuse;
	}
	
	float4 getSpecular()
	{
		return LightSpecular;
	}
	
	LIGHT_RESULT compute(MATERIAL_INFOS material_infos)
	{
		LIGHT_RESULT light_result = (LIGHT_RESULT)0;
		
		light_result.contribution = float4(1.0f,1.0f,1.0f,1.0f);
		
		
		return light_result;
	}
};

struct SLightPoint : Light
{
	const float3 LightPos;
	const float3 LightDir;
	const float3 LightUp;
	const float3 LightRight;
	
	const float4 LightAmbient;
	const float4 LightDiffuse;
	const float4 LightSpecular;
	
	const float LightAxialFalloffStart;
	const float LightAxialFalloffEnd;
	const float LightAxialFalloffConstant;
	const float LightAxialFalloffLinear;
	const float LightAxialFalloffQuadratic;
	
	const float LightRadialInnerCone; /* cosf(InnerConeAngle * 3.14159f / 180.0f) */
	const float LightRadialOuterCone; /* cosf(OuterConeAngle * 3.14159f / 180.0f) */
	const float LightRadialFalloffExponent;
	
	const float LightAreaType;
	const float LightAreaStatus;
	const float2 LightAreaGeometry;
	
	
	float3 getPosition(MATERIAL_INFOS material_infos)
	{
		#ifdef IN_FXCOMPOSER2
		return _LightPos;
		#else
		return LightPos;
		#endif
	}
	
	float3 getDirection(MATERIAL_INFOS material_infos)
	{
		return getPosition(material_infos) - material_infos.position;
	}
	
	float4 getAmbient()
	{
		#ifdef IN_FXCOMPOSER2
		return _LightAmbient;
		#else
		return LightAmbient;
		#endif
	}
	
	float4 getDiffuse()
	{
		#ifdef IN_FXCOMPOSER2
		return _LightDiffuse;
		#else
		return LightDiffuse;
		#endif
	}
	
	float4 getSpecular()
	{
		#ifdef IN_FXCOMPOSER2
		return _LightSpecular;
		#else
		return LightSpecular;
		#endif
	}
	
	LIGHT_RESULT compute(MATERIAL_INFOS material_infos)
	{
		LIGHT_RESULT light_result = (LIGHT_RESULT)0;
		
		light_result.contribution = float4(1.0f,1.0f,1.0f,1.0f);
		
		
		/* Axial Falloff */
		if(LightAxialFalloffConstant <1.0f)
		{
			float distance = length(getDirection(material_infos));
			
			float d = max(distance-LightAxialFalloffStart,0.0f);
			d /= max(LightAxialFalloffEnd - distance,0.001f);
			float axialFalloff = 1.0f/(1.0f + LightAxialFalloffLinear*d + LightAxialFalloffQuadratic*d*d);
			
			light_result.contribution *= axialFalloff;
		}
		
		
		return light_result;
	}
};

struct SLightSpot : Light
{
	const float3 LightPos;
	const float3 LightDir;
	const float3 LightUp;
	const float3 LightRight;
	
	const float4 LightAmbient;
	const float4 LightDiffuse;
	const float4 LightSpecular;
	
	const float LightAxialFalloffStart;
	const float LightAxialFalloffEnd;
	const float LightAxialFalloffConstant;
	const float LightAxialFalloffLinear;
	const float LightAxialFalloffQuadratic;
	
	const float LightRadialInnerCone; /* cosf(InnerConeAngle * 3.14159f / 180.0f) */
	const float LightRadialOuterCone; /* cosf(OuterConeAngle * 3.14159f / 180.0f) */
	const float LightRadialFalloffExponent;
	
	const float LightAreaType;
	const float LightAreaStatus;
	const float2 LightAreaGeometry;
	
	
	float3 getPosition(MATERIAL_INFOS material_infos)
	{
		return LightPos;
	}
	
	float3 getDirection(MATERIAL_INFOS material_infos)
	{
		return getPosition(material_infos) - material_infos.position;
	}
	
	float4 getAmbient()
	{
		return LightAmbient;
	}
	
	float4 getDiffuse()
	{
		return LightDiffuse;
	}
	
	float4 getSpecular()
	{
		return LightSpecular;
	}
	
	LIGHT_RESULT compute(MATERIAL_INFOS material_infos)
	{
		LIGHT_RESULT light_result = (LIGHT_RESULT)0;
		
		light_result.contribution = float4(1.0f,1.0f,1.0f,1.0f);
		
		
		/* Radial Falloff */
		float3 normal = material_infos.normal;
		float3 direction = normalize(getDirection(material_infos));
		
		float lightAngle = dot(direction,normalize(-LightDir));
		lightAngle = clamp(lightAngle,0.0f,1.0f);
		
		float t = lightAngle + (1.0f-LightRadialInnerCone) - LightRadialOuterCone;
		t = clamp(t/(1.0f-LightRadialOuterCone),0.0f,1.0f);
		
		float radialFalloff = clamp((3.0f*t*t*(1.0f-t) + t*t*t),0.0f,1.0f);
		radialFalloff = pow(radialFalloff,LightRadialFalloffExponent);
		
		light_result.contribution *= radialFalloff;
		
		
		/* Axial Falloff */
		if(LightAxialFalloffConstant <1.0f)
		{
			float distance = length(getDirection(material_infos));
			
			float d = max(distance-LightAxialFalloffStart,0.0f);
			d /= max(LightAxialFalloffEnd - distance,0.001f);
			float axialFalloff = 1.0f/(1.0f + LightAxialFalloffLinear*d + LightAxialFalloffQuadratic*d*d);
			
			light_result.contribution *= axialFalloff;
		}
		
		
		return light_result;
	}
};


/******************************************************************/
/* MATERIAL - "UN-TWEAKABLE" PARAMETERS */
/******************************************************************/

/* Lights interface
 * 
 * Functions :
 * float3 getPosition(MATERIAL_INFOS)
 * float3 getDirection(MATERIAL_INFOS)
 * float4 getAmbient()
 * float4 getDiffuse()
 * float4 getSpecular()
 * LIGHT_RESULT compute(MATERIAL_INFOS)
 * 
 */
#ifdef IN_FXCOMPOSER2
SLightPoint lights[1];
#else
Light lights[];
#endif


/* Matrix transformations */
float4x4 World : World;
float4x4 WorldIT : WorldIT;
float4x4 View : View;
float4x4 ViewIT : ViewIT;
float4x4 Wvp : WorldViewProjection;

/* Uncomment the line below if tangent and binormal of the surface are needed */
int NeedTandB = 1;

/* Global Ambient */
float4 GlobalAmbientColor : GLOBALAMBIENTCOLOR;


/******************************************************************/
/* MATERIAL - TWEAKABLE PARAMETERS */
/******************************************************************/

/* Ambient parameters */
float AmbientStrength
<
	float UIMin = 0.0f;
	float UIMax = 20.0f;
> = 0.0f;

float4 AmbientColor : Ambient
<
	string Desc = "Ambient color";
> = {1.0f,1.0f,1.0f,1.0f};


/* Diffuse parameters */
float DiffuseStrength
<
	float UIMin = 0.0f;
	float UIMax = 20.0f;
> = 0.2f;

float4 DiffuseColor : Diffuse
<
	string Desc = "Diffuse color";
> = {1.0f,1.0f,1.0f,1.0f};

float DiffusePower
<
	float UIMin = 0.0f;
	float UIMax = 250.0f;
> = 10.0f;


/* Specular parameters */
float SpecularStrength
<
	float UIMin = 0.0f;
	float UIMax = 20.0f;
> = 0.3f;

float4 SpecularColor : Specular
<
	string Desc = "Specular color";
> = {1.0f,1.0f,1.0f,1.0f};

float SpecularPower
<
	float UIMin = 0.0f;
	float UIMax = 250.0f;
> = 15.0f;


/* Reflection parameters */
float ReflectionStrength
<
	float UIMin = 0.0f;
	float UIMax = 1.0f;
> = 1.0f;

float ReflectionMin
<
	float UIMin = 0.0f;
	float UIMax = 1.0f;
> = 0.0f;

float ReflectionMax
<
	float UIMin = 0.0f;
	float UIMax = 1.0f;
> = 1.0f;

float IOR
<
	float UIMin = 1.0f;
	float UIMax = 10.0f;
> = 1.6f;


/* Varnish parameters */
float VarnishSpecularStrength
<
	float UIMin = 0.0f;
	float UIMax = 20.0f;
> = 0.1f;

float VarnishSpecularPower
<
	float UIMin = 0.0f;
	float UIMax = 250.0f;
> = 25.0f;


/* Braiding parameters */
float4 BraidingColor1
<
	string Desc = "Braiding color 1";
> = {0.6f,0.6f,0.6f,1.0f};

float4 BraidingColor2
<
	string Desc = "Braiding color 2";
> = {0.1f,0.1f,0.1f,1.0f};

float BraidingAnisotropyHeight
<
  float Min = 0.0f;
  float Max = 50.0f;
> = 1.0f;

float BraidingAnisotropyScale
<
  float Min = 0.0f;
  float Max = 100.0f;
> = 4.0f;

float BraidingAnisotropyRatio
<
  float Min = 0.0f;
  float Max = 100.0f;
> = 1.0f;

float BraidingBumpHeight
<
	float UIMin = 0.0f;
	float UIMax = 50.0f;
> = 3.0f;

float BraidingBumpScale
<
  float UIMin = 0.0f;
  float UIMax = 100.0f;
> = 1.0f;

float BraidingBumpRatio
<
  float UIMin = 0.0f;
  float UIMax = 100.0f;
> = 10.0f;

float BraidingAOBlend
<
  float UIMin = 0.0f;
  float UIMax = 1.0f;
> = 0.7f;


/* Environment parameters */
float EnvironmentContrast
<
	float UIMin = 0.0f;
	float UIMax = 10.0f;
> = 1.0f;

float EnvironmentThreshold
<
	float UIMin = 0.0f;
	float UIMax = 1.0f;
> = 0.4f;

float EnvironmentSaturation
<
	float UIMin = 0.0f;
	float UIMax = 10.0f;
> = 1.0f;


/******************************************************************/
/* MATERIAL - TEXTURES */
/******************************************************************/

texture ReflectionTexture
<
	string UIName = "CUBE Reflection Map";
	string ResourceName = "CATIA_Environment_CUBEMap_Hall_1024.dds";
	string ResourceType = "CUBE";
>;

samplerCUBE ReflectionCUBEMap
<
	string File = "CATIA_Environment_CUBEMap_Hall_1024.dds";
> = sampler_state
{
	Texture = <ReflectionTexture>;
	MinFilter = LinearMipMapLinear;
	MagFilter = Linear;
};


texture BraidingNormalTexture
<
	string UIName = "2D Braiding Normal Map";
	string ResourceName = "CATIA_Normal_2DMap_Scratches_1024.dds";
	string ResourceType = "2D";
>;

sampler2D BraidingNormal2DMap
<
	string File = "CATIA_Normal_2DMap_Scratches_1024.dds";
> = sampler_state
{
	Texture = <BraidingNormalTexture>;
	minFilter = LinearMipMapLinear;
	magFilter = Linear;
};


texture BraidingAnisotropyTexture
<
	string UIName = "2D Braiding Anisotropy Map";
	string ResourceName = "CATIA_Anisotropy_2DMap_CarbonPlain_1024.dds";
	string ResourceType = "2D";
>;

sampler2D BraidingAnisotropy2DMap
<
	string File = "CATIA_Anisotropy_2DMap_CarbonPlain_1024.dds";
> = sampler_state
{
	Texture = <BraidingAnisotropyTexture>;
	minFilter = LinearMipMapLinear;
	magFilter = Linear;
};


/******************************************************************/
/* MATERIAL - ILLUMINATION FUNCTION */
/******************************************************************/

/* Lafortune illumination model */
ILLUMINATION_RESULT compute(LIGHT_INFOS light_infos,MATERIAL_INFOS material_infos,
	CAMERA_INFOS camera_infos,LIGHT_RESULT light_result)
{
	ILLUMINATION_RESULT result = (ILLUMINATION_RESULT)0;
	
	/* Lobe shape */
	float diffuseLobeShape = (dot(light_infos.direction,material_infos.normal)+1.0f)/2.0f;
	float specularLobeShape = (dot(-reflect(light_infos.direction,material_infos.normal),
		camera_infos.direction)+1.0f)/2.0f;
	
	/* Lobe attenuation */
	diffuseLobeShape = pow(diffuseLobeShape,DiffusePower);
	specularLobeShape = pow(specularLobeShape,SpecularPower);
	
	/* Lobe normalization */
	diffuseLobeShape *= DiffusePower/(2.0f*3.14f) + 1.0f/3.14f;
	specularLobeShape *= SpecularPower/(2.0f*3.14f) + 1.0f/3.14f;
	
	/* Add lobe contribution */
	result.ambient = light_result.contribution*light_infos.ambient;
	result.diffuse = light_result.contribution*light_infos.diffuse*diffuseLobeShape;
	result.specular = light_result.contribution*light_infos.specular*specularLobeShape;
	
	
	return result;
}


/******************************************************************/
/* MATERIAL - FUNCTIONS */
/******************************************************************/

/* BRDF effect */
float getBRDFEffect(float3 normal,
	float3 light,
	float3 camera,
	float BRDFPower,
	float OldBRDFEffect)
{
	float BRDFEffect = OldBRDFEffect;
	
	/* Lobe shape */
	float lshape = (dot(-reflect(light,normal),camera)+1.0f)/2.0f;
	
	/* Lobe exponent */
	lshape = pow(lshape,BRDFPower);
	
	/* Lobe normalization */
	lshape *= BRDFPower/(2.0f*3.14f) + 1.0f/3.14f;
	
	/* add Lobe contribution */
	BRDFEffect += lshape;
	
	return BRDFEffect;
}

/* Contrast filter */
float4 filterContrast(float4 color, float contrast,float threshold)
{
	float4 colorContrasted = (float4)0;
	
	colorContrasted.x = color.x+(-1+contrast)*(color.x-threshold);
	colorContrasted.y = color.y+(-1+contrast)*(color.y-threshold);
	colorContrasted.z = color.z+(-1+contrast)*(color.z-threshold);
	colorContrasted.a = color.a+(-1+contrast)*(color.a-threshold);
	
	return colorContrasted;
}

/* Saturation filter */
float4 filterSaturation(float4 color, float saturation)
{
	float brightness = (color.x+color.y+color.z)/3;
	float4 colorSaturated = (float4)0;
	
	colorSaturated.x = brightness+(saturation)*(color.x-brightness);
	colorSaturated.y = brightness+(saturation)*(color.y-brightness);
	colorSaturated.z = brightness+(saturation)*(color.z-brightness);
	colorSaturated.a = color.a;
	
	return colorSaturated;
}

/* for spherical environments : (x, y, z) to (alpha, phi) */
float2 getEnvironmentCoords(float3 iVect)
{
	float2 st = float2(0.0f, 0.0f);
	float3 iVect2 = normalize(iVect);
	float x = iVect2.x;
	float y = iVect2.y;
	float z = iVect2.z;

	float m = sqrt(2.0f*(-z+1.0f));
	st.x = ((-x/m)+1.0f)/2.0f;
	st.y = ((-y/m)+1.0f)/2.0f;

	return st;
}

/* Fresnel effect */
float computeFresnel(float3 Wi, float3 Wo, float ior)
{
	float rs = pow((ior - 1.0f)/(ior + 1.0f),2.0f);
	float3 h = normalize(Wi+Wo);
	float c = dot(Wi,h);
	
	float fresnel = rs + (1.0f - rs)*pow(1.0f - c,5.0f);
	
	return fresnel;
}


/******************************************************************/
/* MATERIAL - VERTEX & FRAGMENT STRUCTURES */
/******************************************************************/

struct Application2Vertex
{
	float3 position : POSITION;
	float4 uv : TEXCOORD0;
	float4 normal : NORMAL;
	float4 tangent : TEXCOORD1;
	float4 binormal	: TEXCOORD2;
};

struct Vertex2Fragment
{
	float4 screenPosition : POSITION;
	float2 uv : TEXCOORD0;
	float3 worldPosition : TEXCOORD1;
	float3 worldNormal : TEXCOORD2;
	float3 worldTangent : TEXCOORD3;
	float3 worldBinormal : TEXCOORD4;
	float3 worldEye : TEXCOORD5;
};


/******************************************************************/
/* MATERIAL - VERTEX & FRAGMENT PROGRAMS */
/******************************************************************/

/* Basic Vertex Program */
Vertex2Fragment BasicVP(Application2Vertex IN)
{
	Vertex2Fragment OUT = (Vertex2Fragment)0;
	
	float4 position = float4(IN.position.xyz,1.0f);
	OUT.screenPosition = mul(Wvp,position); 
	
	OUT.uv = IN.uv.xy;
	
	float3 worldPosition = mul(World,position).xyz;
	OUT.worldPosition= worldPosition;
	
	OUT.worldNormal = normalize(mul(WorldIT,IN.normal)).xyz;
	OUT.worldTangent = normalize(mul(WorldIT,IN.tangent)).xyz;
	OUT.worldBinormal = normalize(mul(WorldIT,IN.binormal)).xyz;
	
	OUT.worldEye = ViewIT[3].xyz;
	
	return OUT;
}

/* Carbon Polished Fragment Program */
float4 CarbonPolishedFP(Vertex2Fragment IN,float vf : FACE) : COLOR
{
	/* Vertex input */
	float3 position = IN.worldPosition;
	float2 uv = IN.uv;
	float3 normal = normalize(IN.worldNormal);
	float3 tangent = normalize(IN.worldTangent);
	float3 binormal = normalize(IN.worldBinormal);
	float3 eye = IN.worldEye;
	
	/* Camera information */
	CAMERA_INFOS camera_infos = (CAMERA_INFOS)0;
	camera_infos.position = eye;
	camera_infos.direction = normalize(eye-position);
	
	/* Normal orientation */
	if(vf < 0.0f) normal = -normal;
	float3 worldNormal = normal;
	
	
	/* Anisotropy texture */
	float4 anisotropyColor = tex2D(BraidingAnisotropy2DMap,
		float2(uv.x*BraidingAnisotropyScale,
			uv.y*BraidingAnisotropyScale*BraidingAnisotropyRatio));
	
	/* Anisotropy texture  - B[0.0, 0.5] : Mask */
	float mask = 2.0f*clamp(anisotropyColor.z*2.0f,0.0f,0.5f);
	
	/* Anisotropy texture - B[0.5, 1.0] : Alpha */
	float alpha = clamp((anisotropyColor.z-0.5f)*2.0f,0.0f,1.0f);
	
	/* Anisotropy texture - A : Ambient occlusion */
	BraidingAOBlend = clamp(BraidingAOBlend,0.0f,1.0f);
	float ambientOcclusion = (1.0f - BraidingAOBlend) + BraidingAOBlend*anisotropyColor.a;
	
	/* Anisotropy texture - RG : Normal */
	float2 anisotropy = BraidingAnisotropyHeight*(anisotropyColor.xy-(0.5f).xx);
	
	
	/* Braiding texture */
	float bumpU = (mask*uv.x + (1.0f-mask)*uv.y);
	float bumpV = (mask*uv.y + (1.0f-mask)*uv.x);
	
	float4 braidingColor = tex2D(BraidingNormal2DMap,
		float2(bumpU*BraidingBumpScale,bumpV*BraidingBumpScale*BraidingBumpRatio));
	
	float2 bump = braidingColor.a * BraidingBumpHeight * (braidingColor.xy-(0.5f).xx);
	bump *= (1.0f-alpha)*ambientOcclusion;
	
	float braidingSpecular = (1.0f-alpha)*braidingColor.z;
	
	/* Braiding texture - Color */
	float4 braiding = mask*BraidingColor1 + (1.0f-mask)*BraidingColor2;
	braiding = (1.0f-alpha)*braiding;
	
	
	/* Normal modification */
	normal += (bump.x*tangent + bump.y*binormal);
	normal += (anisotropy.x*tangent + anisotropy.y*binormal);
    normal = normalize(normal);
	
	
	/* Material information */
	MATERIAL_INFOS material_infos = (MATERIAL_INFOS)0;
	material_infos.position = position;
	material_infos.normal = normal;
	material_infos.tangent = tangent;
	material_infos.binormal = binormal;
	
	
	/* Lighting result */
	LIGHT_INFOS light_infos = (LIGHT_INFOS)0;
	LIGHT_RESULT light_result = (LIGHT_RESULT)0;
	ILLUMINATION_RESULT illumination_result = (ILLUMINATION_RESULT)0;
	illumination_result.ambient += GlobalAmbientColor;
	
	float varnish = 0.0f;
	for(int i=0; i<lights.length; i++)
	{
		/* Light information */
		light_infos.position = lights[i].getPosition(material_infos);
		light_infos.direction = normalize(lights[i].getDirection(material_infos));
		light_infos.ambient = lights[i].getAmbient();
		light_infos.diffuse = lights[i].getDiffuse();
		light_infos.specular = lights[i].getSpecular();
		
		/* Light computation */
		light_result = lights[i].compute(material_infos);
		
		/* Illumination computation */
		ILLUMINATION_RESULT ir = compute(light_infos,material_infos,camera_infos,light_result);
		illumination_result.ambient += ir.ambient;
		illumination_result.diffuse += ir.diffuse;
		illumination_result.specular += ir.specular;
		
		/* Varnish specular computation */
		varnish = getBRDFEffect(worldNormal,light_infos.direction,camera_infos.direction,
			VarnishSpecularPower,varnish);
	}
	
	/* Reflection */
	float3 reflected = reflect(-camera_infos.direction,worldNormal);
	float4 reflectionColor = texCUBE(ReflectionCUBEMap,float3(reflected.y,-reflected.z,-reflected.x));
	reflectionColor = filterContrast(reflectionColor,EnvironmentContrast,EnvironmentThreshold);
	reflectionColor = filterSaturation(reflectionColor,EnvironmentSaturation);
	
	/* Fresnel */
	float fresnel = computeFresnel(camera_infos.direction,reflected,IOR);
	fresnel = clamp(fresnel,ReflectionMin,ReflectionMax);
	
	
	/* Material result */
	float4 result = (float4)0;
	
	/* Brading contribution */
	result += illumination_result.ambient*(AmbientStrength*AmbientColor*(braiding+alpha));
	result += illumination_result.diffuse*(DiffuseStrength*DiffuseColor*(braiding+alpha));
	result += illumination_result.specular*(SpecularStrength*SpecularColor*(braiding+braidingSpecular));
	result *= ambientOcclusion;
	
	/* Varnish contribution */
	result += ReflectionStrength*reflectionColor*fresnel;
	result += varnish*VarnishSpecularStrength*SpecularColor;
	
	
	return float4(result.xyz,1.0f);
}


/******************************************************************/
/* MATERIAL - TECHNIQUES */
/******************************************************************/

technique CarbonPolished
{
	pass p0
	{
		/* Uncomment the line below to show stickers correctly */
		PolygonOffset = float2(2.0,2.0);
		
		DepthTestEnable=true;
		DepthMask = true;
		DepthFunc = LEqual;
		
		/* Uncomment the line(s) below to enable transparency */
		//BlendEnable = true;
		#ifdef IN_FXCOMPOSER2
		//BlendFunc = int2(SrcAlpha, One);
		#endif
		
		
		VertexProgram = compile vp40 BasicVP();
		
		FragmentProgram = compile fp40 CarbonPolishedFP();
	}
}

technique CarbonPolishedGLSL
{
	pass p0
	{
		/* Uncomment the line below to show stickers correctly */
		PolygonOffset = float2(2.0,2.0);
		
		DepthTestEnable=true;
		DepthMask = true;
		DepthFunc = LEqual;
		
		/* Uncomment the line(s) below to enable transparency */
		//BlendEnable = true;
		#ifdef IN_FXCOMPOSER2
		//BlendFunc = int2(SrcAlpha, One);
		#endif
		
		
		VertexProgram = compile glslv BasicVP();
		
		FragmentProgram = compile glslf CarbonPolishedFP();
	}
}

